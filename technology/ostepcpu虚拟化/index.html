<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.89.4" /><meta name="theme-color" content="#fff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>OSTEP——CPU虚拟化 | 阿飒的仓库</title>

    <link rel="stylesheet" href="/css/meme.min.a08e80bef7079f21e6b0058264e5cf7ddf695ecd321a1caef5b14665fde1bd63.css"/>

    
    
        <script src="/js/meme.min.8cbe976441b5181abfd3093c9beee209b19cdbb1fa77c48d225a83ba81fa3fb1.js"></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=EB&#43;Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=EB&#43;Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" /></noscript>

    <meta name="author" content="arthur" /><meta name="description" content="……" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="阿飒的仓库" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="阿飒的仓库" />
    <meta name="msapplication-starturl" content="../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2021-12-01T15:43:13+08:00",
        "dateModified": "2021-12-02T20:33:30+08:00",
        "url": "https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/",
        "headline": "OSTEP——CPU虚拟化",
        "description": "……",
        "inLanguage" : "zh-CN",
        "articleSection": "technology",
        "wordCount":  23025 ,
        "image": ["https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-002.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-003.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-004.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-005.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-006.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-007.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-008.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-009.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-010.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-011.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-012.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-013.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-014.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-015.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-016.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-017.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-018.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-019.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-020.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-021.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-022.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-023.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-024.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-025.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-026.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-027.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-028.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-029.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-030.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-031.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-032.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-033.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-034.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-035.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-036.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-037.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-038.png","https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-039.png"],
        "author": {
            "@type": "Person",
            "description": "我是我之所有因果的指向",
            "email": "18609106346@163.com",
            "image": "https://Arthur940621.github.io/icons/apple-touch-icon.png",
            "url": "https://arthur940621.github.io/",
            "name": "arthur"
        },
        "publisher": {
            "@type": "Organization",
            "name": "阿飒的仓库",
            "logo": {
                "@type": "ImageObject",
                "url": "https://Arthur940621.github.io/icons/apple-touch-icon.png"
            },
            "url": "https://Arthur940621.github.io/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "https://Arthur940621.github.io/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary_large_image" />



    



<meta property="og:title" content="OSTEP——CPU虚拟化" />
<meta property="og:description" content="……" />
<meta property="og:url" content="https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/" />
<meta property="og:site_name" content="阿飒的仓库" />
<meta property="og:locale" content="zh" /><meta property="og:image" content="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png" />
<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2021-12-01T15:43:13&#43;08:00" />
    <meta property="article:modified_time" content="2021-12-02T20:33:30&#43;08:00" />
    
    <meta property="article:section" content="technology" />



    
    

    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">阿飒的仓库</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/technology/"><svg t="1637754536610" class="icon technology" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2796" width="200" height="200"><path d="M204.8 860.842667h568.832" fill="#FFFFFF" p-id="2797"></path><path d="M136.533333 217.429333h705.365334a34.133333 34.133333 0 0 1 34.133333 34.133334v432.469333A22.698667 22.698667 0 0 1 853.333333 706.730667H125.098667A22.698667 22.698667 0 0 1 102.4 684.032V251.562667a34.133333 34.133333 0 0 1 34.133333-34.133334z" fill="#FCFEFF" p-id="2798"></path><path d="M876.032 251.562667v432.298666A22.698667 22.698667 0 0 1 853.333333 706.730667H474.453333l178.176-489.301334h189.269334a34.133333 34.133333 0 0 1 34.133333 34.133334z" fill="#EDF4FF" p-id="2799"></path><path d="M716.8 860.842667H261.632a57.002667 57.002667 0 0 1 57.002667-56.832h341.333333A56.832 56.832 0 0 1 716.8 860.842667z" fill="#FFFFFF" p-id="2800"></path><path d="M598.528 706.730667h-218.453333l-27.306667 97.28h273.066667l-27.306667-97.28z" fill="#C3CFDE" p-id="2801"></path><path d="M876.032 251.562667v68.266666H102.4v-68.266666a34.133333 34.133333 0 0 1 34.133333-34.133334h705.365334a34.133333 34.133333 0 0 1 34.133333 34.133334z" fill="#96DDFF" p-id="2802"></path><path d="M841.898667 217.429333H652.629333l-37.205333 102.4h260.608v-68.266666a34.133333 34.133333 0 0 0-34.133333-34.133334z" fill="#69BAF9" p-id="2803"></path><path d="M716.8 860.842667H261.632a57.002667 57.002667 0 0 1 57.002667-56.832h341.333333A56.832 56.832 0 0 1 716.8 860.842667z" fill="#EDF4FF" p-id="2804"></path><path d="M782.165333 903.168a158.549333 158.549333 0 0 0 25.6-2.048 21.845333 21.845333 0 0 1 22.698667 10.581333 22.016 22.016 0 0 0 30.208 8.021334l36.010667-20.821334a22.186667 22.186667 0 0 0 7.850666-30.037333 22.186667 22.186667 0 0 1 2.048-25.088 160.256 160.256 0 0 0 25.6-44.544 22.016 22.016 0 0 1 21.162667-14.165333 22.186667 22.186667 0 0 0 22.186667-22.186667v-41.642667a22.186667 22.186667 0 0 0-22.186667-22.186666 22.016 22.016 0 0 1-20.650667-14.336 162.645333 162.645333 0 0 0-25.6-44.544 21.845333 21.845333 0 0 1-2.56-24.917334 22.357333 22.357333 0 0 0-8.192-30.378666l-36.010666-20.821334a22.016 22.016 0 0 0-30.208 8.192 22.016 22.016 0 0 1-22.698667 10.752 148.821333 148.821333 0 0 0-51.2 0 22.016 22.016 0 0 1-22.357333-10.752 22.186667 22.186667 0 0 0-30.208-8.192l-36.010667 20.821334a22.357333 22.357333 0 0 0-8.192 30.378666 21.845333 21.845333 0 0 1-2.048 24.917334A162.645333 162.645333 0 0 0 631.466667 684.714667a22.016 22.016 0 0 1-20.48 15.018666 22.186667 22.186667 0 0 0-22.186667 22.186667v40.96a22.186667 22.186667 0 0 0 22.186667 22.186667 22.016 22.016 0 0 1 20.650666 14.165333 160.256 160.256 0 0 0 25.6 44.544 22.186667 22.186667 0 0 1 2.048 25.088 22.186667 22.186667 0 0 0 8.192 30.208l36.010667 20.821333a22.016 22.016 0 0 0 30.378667-8.021333 21.845333 21.845333 0 0 1 22.698666-10.581333 158.549333 158.549333 0 0 0 25.6 1.877333z" fill="#79DEB4" p-id="2805"></path><path d="M975.530667 721.066667v41.642666a22.186667 22.186667 0 0 1-22.186667 22.186667 22.186667 22.186667 0 0 0-20.650667 14.336 162.645333 162.645333 0 0 1-25.6 44.544 22.528 22.528 0 0 0-4.949333 13.994667 20.992 20.992 0 0 0 2.901333 10.922666 22.357333 22.357333 0 0 1-8.192 30.378667l-36.010666 20.821333a22.016 22.016 0 0 1-30.208-8.192 22.016 22.016 0 0 0-22.698667-10.752 148.821333 148.821333 0 0 1-51.2 0 22.016 22.016 0 0 0-22.698667 10.752 22.186667 22.186667 0 0 1-30.208 8.192l-36.010666-20.821333a22.357333 22.357333 0 0 1-8.192-30.378667 20.821333 20.821333 0 0 0 2.389333-6.144l240.64-241.152a21.674667 21.674667 0 0 0 4.437333 18.773334 162.645333 162.645333 0 0 1 25.6 44.544 22.186667 22.186667 0 0 0 20.650667 14.336 22.186667 22.186667 0 0 1 22.186667 22.016z" fill="#62CCA1" p-id="2806"></path><path d="M782.165333 742.058667m-60.416 0a60.416 60.416 0 1 0 120.832 0 60.416 60.416 0 1 0-120.832 0Z" fill="#FCFEFF" p-id="2807"></path><path d="M159.232 268.629333m-17.066667 0a17.066667 17.066667 0 1 0 34.133334 0 17.066667 17.066667 0 1 0-34.133334 0Z" fill="#3D3D63" p-id="2808"></path><path d="M273.066667 268.629333m-17.066667 0a17.066667 17.066667 0 1 0 34.133333 0 17.066667 17.066667 0 1 0-34.133333 0Z" fill="#3D3D63" p-id="2809"></path><path d="M216.234667 268.629333m-17.066667 0a17.066667 17.066667 0 1 0 34.133333 0 17.066667 17.066667 0 1 0-34.133333 0Z" fill="#3D3D63" p-id="2810"></path><path d="M341.333333 516.266667l51.2-51.2a17.066667 17.066667 0 1 0-24.234666-24.234667l-63.488 63.658667a17.066667 17.066667 0 0 0 0 24.064l63.488 63.658666a17.066667 17.066667 0 0 0 24.234666 0 17.066667 17.066667 0 0 0 0-24.064zM585.728 591.872a17.066667 17.066667 0 0 0 24.064 0L673.450667 529.066667a17.066667 17.066667 0 0 0 0-24.064l-63.658667-63.658667a17.066667 17.066667 0 0 0-24.064 24.234667l51.2 51.2-51.2 51.2a17.066667 17.066667 0 0 0 0 23.893333zM529.066667 446.293333a17.066667 17.066667 0 0 0-23.381334 6.314667L442.709333 563.2a17.066667 17.066667 0 1 0 29.525334 17.066667l63.658666-110.08a17.066667 17.066667 0 0 0-6.826666-23.893334z" fill="#3D3D63" p-id="2811"></path><path d="M953.344 682.666667a4.949333 4.949333 0 0 1-4.608-3.242667 178.005333 178.005333 0 0 0-28.501333-49.322667 4.949333 4.949333 0 0 1 0-5.632 39.253333 39.253333 0 0 0-14.336-53.589333l-12.8-7.68V251.562667a51.2 51.2 0 0 0-51.2-51.2H136.533333a51.2 51.2 0 0 0-51.2 51.2v432.469333a39.936 39.936 0 0 0 39.765334 39.765333H358.4l-17.066667 63.146667h-22.698666a73.898667 73.898667 0 0 0-71.850667 56.832H204.8a17.066667 17.066667 0 0 0 0 34.133333h434.688a36.181333 36.181333 0 0 0 1.194667 12.117334 38.4 38.4 0 0 0 18.261333 23.893333l36.010667 20.821333a39.253333 39.253333 0 0 0 53.589333-14.506666 5.290667 5.290667 0 0 1 5.290667-2.389334 166.229333 166.229333 0 0 0 56.661333 0 5.12 5.12 0 0 1 5.290667 2.56 39.253333 39.253333 0 0 0 34.133333 19.456 38.741333 38.741333 0 0 0 19.626667-5.12l36.010666-20.821333a39.082667 39.082667 0 0 0 18.261334-23.893333 38.570667 38.570667 0 0 0-3.925334-29.696 5.12 5.12 0 0 1 0-5.802667 179.541333 179.541333 0 0 0 28.501334-49.152 4.778667 4.778667 0 0 1 4.608-3.242667 39.424 39.424 0 0 0 39.253333-39.253333v-41.642667A39.253333 39.253333 0 0 0 953.344 682.666667zM119.466667 251.562667a17.066667 17.066667 0 0 1 17.066666-17.066667h705.365334a17.066667 17.066667 0 0 1 17.066666 17.066667v51.2H119.466667z m5.632 438.101333a5.632 5.632 0 0 1-5.632-5.632V336.896h739.498666V546.133333a39.082667 39.082667 0 0 0-43.178666 17.066667 4.949333 4.949333 0 0 1-5.12 2.218667 175.274667 175.274667 0 0 0-56.661334 0 4.778667 4.778667 0 0 1-5.12-2.218667 39.082667 39.082667 0 0 0-53.589333-14.336l-36.010667 20.821333a38.229333 38.229333 0 0 0-18.261333 23.722667 39.594667 39.594667 0 0 0 3.754667 29.866667 4.608 4.608 0 0 1 0 5.632 178.005333 178.005333 0 0 0-28.501334 49.322666 4.949333 4.949333 0 0 1-4.608 3.242667 39.082667 39.082667 0 0 0-23.210666 7.68zM580.266667 786.944H375.466667l17.066666-63.146667h179.2v39.082667a39.594667 39.594667 0 0 0 8.533334 24.064z m-261.461334 34.133333h303.786667a187.733333 187.733333 0 0 0 13.312 22.698667H282.794667a39.765333 39.765333 0 0 1 35.84-22.698667z m639.658667-58.197333a5.12 5.12 0 0 1-5.12 5.12 39.424 39.424 0 0 0-36.693333 25.258667 144.384 144.384 0 0 1-22.869334 39.765333 39.424 39.424 0 0 0-3.584 44.373333 4.437333 4.437333 0 0 1 0 3.754667 4.949333 4.949333 0 0 1-2.389333 3.242667L852.309333 904.533333a5.12 5.12 0 0 1-6.997333-2.048 39.424 39.424 0 0 0-40.448-18.944 135.168 135.168 0 0 1-45.397333 0 39.424 39.424 0 0 0-40.448 19.114667 5.290667 5.290667 0 0 1-6.997334 1.877333l-36.010666-20.821333a4.949333 4.949333 0 0 1-2.389334-3.242667 4.437333 4.437333 0 0 1 0-3.754666 39.765333 39.765333 0 0 0-3.584-44.373334 142.506667 142.506667 0 0 1-23.04-39.765333A38.912 38.912 0 0 0 610.986667 768a5.12 5.12 0 0 1-5.12-5.12v-41.642667a4.949333 4.949333 0 0 1 5.12-5.12 39.253333 39.253333 0 0 0 36.522666-25.258666 140.117333 140.117333 0 0 1 23.04-39.765334 39.765333 39.765333 0 0 0 3.584-44.373333 4.778667 4.778667 0 0 1 0-3.925333 4.437333 4.437333 0 0 1 2.389334-3.072l36.010666-20.821334a4.778667 4.778667 0 0 1 2.56 0 5.12 5.12 0 0 1 4.266667 2.389334 39.594667 39.594667 0 0 0 40.448 19.114666 135.168 135.168 0 0 1 45.397333 0A39.765333 39.765333 0 0 0 845.312 580.266667a4.949333 4.949333 0 0 1 6.826667-1.706667l36.010666 20.821333a4.437333 4.437333 0 0 1 2.389334 3.072 4.778667 4.778667 0 0 1 0 3.925334 39.253333 39.253333 0 0 0 3.584 44.202666 145.237333 145.237333 0 0 1 22.869333 39.936A39.594667 39.594667 0 0 0 953.344 716.8a4.949333 4.949333 0 0 1 5.12 5.12z" fill="#3D3D63" p-id="2812"></path><path d="M782.165333 664.576a77.482667 77.482667 0 1 0 77.482667 77.482667 77.482667 77.482667 0 0 0-77.482667-77.482667z m0 120.832a43.349333 43.349333 0 1 1 43.349334-43.349333A43.349333 43.349333 0 0 1 782.165333 785.066667z" fill="#3D3D63" p-id="2813"></path></svg><span class="menu-item-name">技术</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/guitar/"><svg class="icon guitar" width="200px" height="200.00px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M575.744 717.952c19.072-38.656 19.968-52.672 64.704-93.824a579.2 579.2 0 0 1 43.072-35.776c41.216-38.976 63.872-81.344 29.824-118.4l-119.04-129.408c-34.944-37.952-80.384-17.216-123.648 22.464l-13.312 9.152c-8.064 8.384-16.512 16.64-25.472 24.896-50.304 46.208-70.336 48.128-113.408 61.632l-2.048 1.408c-34.112 4.16-106.496 53.568-140.8 85.056-62.016 56.96-84.288 133.632-49.792 171.264 1.856 1.92 3.968 3.712 5.952 5.504l-0.448 0.384 178.624 194.432 1.024-0.896c37.824 27.008 108.736 9.664 165.888-42.816 41.984-38.592 98.816-116.8 98.88-155.072z" fill="#E88F22" /><path d="M859.648 166.528l56.768 61.824-416 382.272-56.768-61.76z" fill="#5B4037" /><path d="M515.904 538.112l-3.072 98.944-98.816-3.072 3.072-98.88z" fill="#3C2622" /><path d="M810.432 163.008l105.152 114.496-82.624 75.84-105.152-114.496z" fill="#5B4037" /><path d="M847.36 153.088l81.472 88.64-139.904 128.64L707.456 281.6z" fill="#B5612C" /><path d="M385.152 740.928l-81.472-88.64 25.152-46.976 105.152 114.496z" fill="#5B4037" /><path d="M844.864 200.64l14.4 15.616-27.072 24.768-14.336-15.616zM789.312 251.648l14.4 15.616-27.072 24.896-14.336-15.68zM866.56 224.256l14.464 15.616-27.008 24.96-14.4-15.616zM811.072 275.328l14.4 15.616-27.008 24.96-14.464-15.616z" fill="#E1C2AD" /></svg><span class="menu-item-name">指弹</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/harmonica/"><svg class="icon harmonica" width="200px" height="200.00px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M965.312 620.288a20.096 20.096 0 0 1-20.16 20.16H89.6a20.096 20.096 0 0 1-20.16-20.16V411.328c0-11.136 9.024-20.096 20.16-20.096h855.488c11.2 0 20.16 9.024 20.16 20.096v208.96z" fill="#358BCB" /><path d="M155.008 344h724.672v328.448H155.008z" fill="#4EAEE3" /><path d="M965.312 634.624c0 3.2-9.024 5.888-20.16 5.888H89.6c-11.2 0-20.16-2.688-20.16-5.888v-60.608c0-3.2 9.024-5.888 20.16-5.888h855.488c11.2 0 20.16 2.688 20.16 5.888v60.608z" fill="#F5BB1B" /><path d="M140.8 588.288h32.576v32.576H140.8zM206.464 588.288h32.64v32.576h-32.64zM272.128 588.288h32.704v32.576h-32.704zM337.856 588.288h32.576v32.576h-32.576zM666.304 588.288h32.704v32.576h-32.704zM732.032 588.288h32.64v32.576h-32.64zM797.76 588.288h32.576v32.576h-32.576zM863.36 588.288H896v32.576h-32.64zM403.584 588.288h32.576v32.576h-32.576zM469.248 588.288h32.64v32.576h-32.64zM534.848 588.288h32.704v32.576h-32.704zM600.64 588.288h32.576v32.576h-32.576z" fill="#775548" /></svg><span class="menu-item-name">口琴</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/life/"><svg t="1637754482809" class="icon life" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2456" width="200" height="200"><path d="M933.4 701.1V509.7c0-93.8-65.3-173.1-152.7-194.7-3.1-0.8-9.4-2.1-9.4-2.1l0.3 173.4c0 9.2-8.4 15.7-17.5 14.1-11.9-2.1-24-3.3-36.5-3.3H550.1V464c0-12.4 4.9-24.6 14.1-32.9 44-39.9 71.2-98.1 69.2-162.6-3.3-110-95.1-201.5-205-204.5-119.4-3.3-217.1 92.4-217.1 211 0 3 0.4 6 0.5 9h-0.5v112.5h38.8c5.8 8.1 12.1 15.9 18.9 23.2 7.6 8.1 11.4 19.1 11.4 30.2V501C162.7 522.2 75.2 633 92.1 759.7c15.5 115.9 119.1 199.9 236 199.9h389.5c18.9 0 37.4-1.9 54.7-7.3 20.5-6.5 55.3-20.5 77-37.9 7.6-5.9 14.9-12.1 21.6-18.9 1.8-1.7 3.8-3.4 5.6-5.1 36.2-35.4 56.8-83.7 56.8-134.3v-0.4c0.2-4.2 0.6-8.3 0.6-12.5v-29.5c0.1-4.3-0.3-8.4-0.5-12.6z" fill="#FFD778" p-id="2457"></path><path d="M440.1 251.5m-46.3 0a46.3 46.3 0 1 0 92.6 0 46.3 46.3 0 1 0-92.6 0Z" fill="#FB813A" p-id="2458"></path><path d="M272.6 348.5l-122.6-0.3c-22 0-40.1 18-40.1 40s18 40.1 40 40.1l122.5 0.3c22 0 40.1-18 40.1-40 0.1-22-17.9-40-39.9-40.1z" fill="#FB813A" p-id="2459"></path></svg><span class="menu-item-name">生活</span></a>
                </li>
            
        
            
                
                    
                    
                        <li class="menu-item">
                            <a id="theme-switcher" href="#"><svg class="icon theme-icon-light" width="200px" height="200.00px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M511.925344 256.111984c-141.398046 0-255.962672 114.564626-255.962672 255.962672s114.564626 255.962672 255.962672 255.962672 255.962672-114.564626 255.962672-255.962672-114.564626-255.962672-255.962672-255.962672z" fill="#FFBB00" /><path d="M511.925344 239.602391c150.228758 0 272.472264 122.222176 272.450934 272.472265 0 150.228758-122.222176 272.472264-272.450934 272.472264-150.228758 0-272.472264-122.222176-272.472264-272.472264 0-150.228758 122.222176-272.472264 272.472264-272.472265z m0 478.92749c113.839398 0 206.476556-92.615827 206.476556-206.455225 0-113.839398-92.637157-206.476556-206.476556-206.476556s-206.476556 92.637157-206.476555 206.476556 92.637157 206.476556 206.476555 206.476555z m0-521.758577a32.997854 32.997854 0 0 1-32.997854-32.997854V33.147166a32.997854 32.997854 0 1 1 65.995709 0v130.626284c0 18.21601-14.781844 32.997854-32.997855 32.997854z m0 630.606703c18.21601 0 32.997854 14.781844 32.997855 33.019185v130.604954a32.997854 32.997854 0 0 1-65.995709 0V860.397192c0-18.23734 14.760514-33.019185 32.997854-33.019185z m478.92749-348.322536a32.997854 32.997854 0 0 1 0 66.017039h-130.626284a32.997854 32.997854 0 0 1 0-65.995709h130.626284zM196.621993 512.074656c0 18.23734-14.781844 32.997854-32.997855 32.997854H32.997854a32.997854 32.997854 0 0 1 0-65.995709h130.626284c18.21601 0 32.997854 14.781844 32.997855 32.997855zM759.142625 297.833899a32.997854 32.997854 0 0 1-23.335264-56.333118l92.359865-92.359864a32.997854 32.997854 0 1 1 46.670527 46.670527l-92.359864 92.359864a32.912534 32.912534 0 0 1-23.335264 9.662591zM243.249859 734.079613a32.997854 32.997854 0 1 1 46.670528 46.670528l-92.359865 92.359864a32.891203 32.891203 0 0 1-23.335263 9.662591 32.997854 32.997854 0 0 1-23.335264-56.333118l92.359864-92.359865z m539.24936 0l92.359864 92.359865a32.997854 32.997854 0 0 1-46.670527 46.670527l-92.359864-92.359864a32.997854 32.997854 0 1 1 46.670527-46.670528zM243.249859 288.171308l-92.359864-92.359864a32.997854 32.997854 0 1 1 46.670527-46.670527l92.359865 92.359864a32.997854 32.997854 0 1 1-46.670528 46.670527z" fill="#000000" /></svg><svg class="icon theme-icon-dark" width="200px" height="200.00px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M737.373 740.060c0.143 0 0.311 0 0.481 0 79.247 0 152.484-25.733 211.81-69.299-62.252 174.042-227.511 298.298-421.842 298.298-246.432 0-446.229-199.797-446.229-446.229s199.797-446.229 446.229-446.229c5.434 0 10.863 0.137 16.263 0.333-100.084 63.876-166.439 175.899-166.439 303.405 0 198.656 161.071 359.722 359.727 359.722z" fill="#FFB578" /><path d="M527.817 990.905c-258.097 0-468.075-209.978-468.075-468.075s209.978-468.075 468.075-468.075c5.707 0 11.409 0.137 17.077 0.35 11.712 0.444 21.039 10.045 21.039 21.825 0 7.706-3.991 14.48-10.019 18.367-97.975 62.535-156.422 169.070-156.422 285.041 0 186.308 151.573 337.882 337.882 337.882 71.817 0 140.444-22.276 198.454-64.433 3.553-2.606 8.013-4.17 12.836-4.17 12.065 0 21.845 9.78 21.845 21.845 0 2.608-0.458 5.11-1.296 7.429-65.931 186.565-243.337 312.012-441.397 312.012zM476.802 101.499c-210.032 25.286-373.364 204.598-373.364 421.331 0 234.007 190.377 424.384 424.384 424.384 157.041 0 299.756-86.982 373.113-222.031-50.752 24.166-106.261 36.727-163.562 36.727-210.398 0-381.572-171.174-381.572-381.572 0-107.255 44.258-207.361 121.002-278.839z" fill="#4F46A3" /><path d="M795.673 572.741h-176.019c-12.062-0.007-21.838-9.788-21.838-21.851 0-7.585 3.865-14.268 9.732-18.186l115.297-76.006h-103.198c-12.065 0-21.845-9.78-21.845-21.845s9.78-21.845 21.845-21.845h176.019c12.062 0.007 21.838 9.788 21.838 21.851 0 7.585-3.865 14.268-9.732 18.186l-115.297 76.006h103.198c12.065 0 21.845 9.78 21.845 21.845s-9.78 21.845-21.845 21.845zM895.321 338.041h-108.031c-12.062-0.007-21.838-9.788-21.838-21.851 0-7.585 3.865-14.268 9.732-18.186l47.303-31.18h-35.198c-12.065 0-21.845-9.78-21.845-21.845s9.78-21.845 21.845-21.845h108.031c12.062 0.007 21.838 9.788 21.838 21.851 0 7.585-3.865 14.268-9.732 18.186l-47.303 31.18h35.198c12.065 0 21.845 9.78 21.845 21.845s-9.78 21.845-21.845 21.845zM937.23 131.34h-91.264c-12.062-0.007-21.838-9.788-21.838-21.851 0-7.585 3.865-14.268 9.732-18.186l30.521-20.115h-18.421c-12.065 0-21.845-9.78-21.845-21.845 0-12.065 9.78-21.845 21.845-21.845h91.264c12.062 0.007 21.838 9.788 21.838 21.851 0 7.585-3.865 14.268-9.732 18.186l-30.521 20.115h18.421c12.065 0 21.845 9.78 21.845 21.845s-9.78 21.845-21.845 21.845z" fill="#4F46A3" /></svg></a>
                        </li>
                    
                
            
        
            
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="justify" data-type="technology" data-toc-num="true">

            <h1 class="post-title p-name">OSTEP——CPU虚拟化</h1>

            

            
                
            

            
                

<div class="post-meta">
    
        
        <time datetime="2021-12-01T15:43:13&#43;08:00" class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"/></svg>&nbsp;2021.12.1</time>
    
    
        
        <time datetime="2021-12-02T20:33:30&#43;08:00" class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M400 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 400H54a6 6 0 0 1-6-6V160h352v298a6 6 0 0 1-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2021.12.2</time>
    
    
    
        
        
        
            
        
    
    
        
        <span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;23025</span>
    
    
        
        <span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;46&nbsp;分钟</span>
    
    
    
</div>

            

            <div class="post-body e-content">
                <h1 id="抽象进程"><a href="#抽象进程" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>抽象：进程</h1>
<p>进程的非正式定义：进程就是运行中的程序。</p>
<p>程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。</p>
<p>时分共享——操作系统通过虚拟化 <code>CPU</code>。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点。例如，在使用计算机的时候，同时运行浏览器、邮件、游戏、音乐播放器，等等。</p>
<p>空分共享——资源在空间上被划分给希望使用它的人。例如，磁盘空间是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。</p>
<p>机制——一些低级方法或协议，实现了所需的功能。例如，上下文切换，它让操作系统能够停止运行一个程序，并开始在给定的 <code>CPU</code> 上运行另一个程序。</p>
<p>策略——在操作系统内做出某种决定的算法。例如，给定一组可能的程序要在 <code>CPU</code> 上运行，操作系统应该运行哪个程序？操作系统中的调度策略会做出这样的决定，可能利用历史信息（例如，哪个程序在最后一分钟运行得更多？）、工作负载知识（例如，运行什么类型的程序？）以及性能指标（例如，系统是否针对交互式性能或吞吐量进行优化？）来做出决定。</p>
<h2 id="抽象进程概念"><a href="#抽象进程概念" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>抽象：进程概念</h2>
<p>操作系统为正在运行的程序提供的抽象，就是所谓的进程。</p>
<p>一个进程只是一个正在运行的程序。在任何时刻，可以清点它在执行过程中访问或影响的系统的不同部分，从而概括一个进程。</p>
<p>机器状态——程序在运行时可以读取或更新的内容。</p>
<p>指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间）是该进程的一部分。</p>
<p>进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器。</p>
<p>还有一些非常特殊的寄存器构成了该机器状态的一部分，例如，程序计数器（<code>PC</code>）告诉我们程序当前正在执行哪个指令；栈指针和相关的帧指针用于管理函数参数栈、局部变量和返回地址。</p>
<p>最后，程序也经常访问持久存储设备。此类 <code>I/O</code> 信息可能包含当前打开的文件列表。</p>
<h2 id="进程-api"><a href="#进程-api" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>进程 <code>API</code></h2>
<p>所有现代操作系统都以某种形式提供这些API：</p>
<p>创建（<code>create</code>）：操作系统必须包含一些创建新进程的方法。在shell中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。</p>
<p>销毁（<code>destroy</code>）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。
等待（<code>wait</code>）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。</p>
<p>其他控制（<code>miscellaneous control</code>）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。</p>
<p>状态（<code>statu</code>）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。</p>
<h2 id="进程创建更多细节"><a href="#进程创建更多细节" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>进程创建：更多细节</h2>
<p>操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png" alt=""></p>
<p>在早期的（或简单的）操作系统中，加载过程尽早完成，即在运行程序之前全部完成；</p>
<p>现代操作系统惰性执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。</p>
<p>只要记住在运行任何程序之前，操作系统显然必须做一些工作，才能将重要的程序字节从磁盘读入内存。</p>
<p>将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈分配一些内存。<code>C</code> 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。操作系统也可能会用参数初始化栈。具体来说，它会将参数填入main()函数，即argc和argv数组。</p>
<p>操作系统也可能为程序的堆分配一些内存。在 <code>C</code> 程序中，堆用于显式请求的动态分配数据。程序通过调用 <code>malloc()</code> 来请求这样的空间，并通过调用 <code>free()</code> 来明确地释放它。数据结构需要堆。起初堆会很小。随着程序运行，通过 <code>malloc()</code> 库 <code>API</code> 请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。</p>
<p>操作系统还将执行一些其他初始化任务，特别是与输入/输出（<code>I/O</code>）相关的任务。例如，在 <code>UNIX</code> 系统中，默认情况下每个进程都有 <code>3</code> 个打开的文件描述符，用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。</p>
<p>通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 <code>I/O</code> 设置相关的其他工作后，就可以启动程序了，在入口处运行，即 <code>main()</code>。通过跳转到 <code>main()</code> 例程，<code>OS</code> 将 <code>CPU</code> 的控制权转移到新创建的进程中，从而程序开始执行。</p>
<h2 id="进程状态"><a href="#进程状态" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>进程状态</h2>
<p>简而言之，进程可以处于以下3种状态之一：
运行（<code>running</code>）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。</p>
<p>就绪（<code>ready</code>）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。</p>
<p>阻塞（<code>blocked</code>）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。</p>
<p>如图所示，可以根据操作系统的载量，让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（<code>scheduled</code>）。从运行转移到就绪意味着该进程已经取消调度（<code>descheduled</code>）。一旦进程被阻塞（例如，通过发起 <code>I/O</code> 操作），<code>OS</code> 将保持进程的这种状态，直到发生某种事件（例如，<code>I/O</code> 完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-002.png" alt=""></p>
<p>两个正在运行的进程，每个进程只使用 <code>CPU</code>（它们没有<code>I/O</code>）。在这种情况下，每个进程的状态可能如表所示：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-003.png" alt=""></p>
<p>第一个进程在运行一段时间后发起I/O请求。此时，该进程被阻塞，让另一个进程有机会运行（例如，当从磁盘读取数据或等待网络数据包时，进程会被阻塞。<code>OS</code> 发现 <code>Process0</code> 不使用 <code>CPU</code>）：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-004.png" alt=""></p>
<p>即使在这个简单的例子中，操作系统也必须做出许多决定。首先，系统必须决定在 <code>Process0</code> 发出 <code>I/O</code> 时运行 <code>Process1</code>。这样做可以通过保持 <code>CPU</code> 繁忙来提高资源利用率。其次，当 <code>I/O</code> 完成时，系统决定不切换回 <code>Process0</code>。目前还不清楚这是不是一个很好的决定。</p>
<h2 id="数据结构"><a href="#数据结构" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>数据结构</h2>
<p>操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。例如，为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表，以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当 <code>I/O</code> 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// the registers xv6 will save and restore
</span><span class="c1">// to stop and subsequently restart a process
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">context</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">eip</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">esp</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ebx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ecx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">edx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">esi</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">edi</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ebp</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// the different states a process can be in
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">proc_state</span> <span class="p">{</span> <span class="n">UNUSED</span><span class="p">,</span> <span class="n">EMBRYO</span><span class="p">,</span> <span class="n">SLEEPING</span><span class="p">,</span>
                  <span class="n">RUNNABLE</span><span class="p">,</span> <span class="n">RUNNING</span><span class="p">,</span> <span class="n">ZOMBIE</span> <span class="p">};</span>

<span class="c1">// the information xv6 tracks about each process
</span><span class="c1">// including its register context and state
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">proc</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>                   <span class="c1">// Start of process memory
</span><span class="c1"></span>  <span class="n">uint</span> <span class="n">sz</span><span class="p">;</span>                     <span class="c1">// Size of process memory
</span><span class="c1"></span>  <span class="kt">char</span> <span class="o">*</span><span class="n">kstack</span><span class="p">;</span>                <span class="c1">// Bottom of kernel stack
</span><span class="c1"></span>                               <span class="c1">// for this process
</span><span class="c1"></span>  <span class="k">enum</span> <span class="nc">proc_state</span> <span class="n">state</span><span class="p">;</span>       <span class="c1">// Process state
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>                     <span class="c1">// Process ID
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">proc</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>         <span class="c1">// Parent process
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>                  <span class="c1">// If non-zero, sleeping on chan
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">killed</span><span class="p">;</span>                  <span class="c1">// If non-zero, have been killed
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span>  <span class="c1">// Open files
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">inode</span> <span class="o">*</span><span class="n">cwd</span><span class="p">;</span>           <span class="c1">// Current directory
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">context</span> <span class="n">context</span><span class="p">;</span>      <span class="c1">// Switch here to run process
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">trapframe</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>        <span class="c1">// Trap frame for the
</span><span class="c1"></span>                               <span class="c1">// current interrupt
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table></div>
</div>
</div><p>操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。</p>
<p>除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状态。有时候系统会有一个初始（<code>initial</code>）状态，表示进程在创建时处于的状态。另外，一个进程可以处于已退出但尚未清理的最终（<code>final</code>）状态（在基于 <code>UNIX</code> 的系统中，这称为僵尸状态）。</p>
<p>存储关于进程的信息的个体结构称为进程控制块（<code>Process Control Block</code>，<code>PCB</code>）。</p>
<h1 id="插叙进程api"><a href="#插叙进程api" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>插叙：进程API</h1>
<p><code>UNIX</code> 系统通过一对系统调用创建新进程——<code>fork()</code> 和 <code>exec()</code>。</p>
<p>进程还可以通过第三个系统调用 <code>wait()</code>，来等待其创建的子进程执行完成。</p>
<h2 id="fork-系统调用"><a href="#fork-系统调用" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>fork()</code> 系统调用</h2>
<p>系统调用 <code>fork(</code>) 用于创建新进程：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p1.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fork failed; exit
</span><span class="c1"></span>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;fork failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// child (new process)
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// parent goes down this path (main)
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am parent of %d (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>得到输出如下：</p>
<pre tabindex="0"><code>hello world (pid:3949)
hello, I am parent of 3950 (pid:3949)
hello, I am child (pid:3950)
</code></pre><p>当它刚开始运行时，进程输出一条 <code>hello world</code> 信息，以及自己的进程描述符（<code>PID</code>）。该进程的 <code>PID</code> 是 <code>3949</code>。在 <code>UNIX</code> 系统中，如果要操作某个进程（如终止进程），就要通过 <code>PID</code> 来指明。</p>
<p>紧接着进程调用了 <code>fork()</code> 系统调用，这是操作系统提供的创建新进程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这时看起来有两个完全一样的 <code>p1</code> 程序在运行，并都从 <code>fork()</code> 系统调用中返回。新创建的进程称为子进程，原来的进程称为父进程。子进程不会从 <code>main()</code> 函数开始执行（因此<code> hello world</code> 信息只输出了一次），而是直接从 <code>fork()</code> 系统调用返回，就好像是它自己调用了 <code>fork()</code>。</p>
<p>子进程并不是完全拷贝了父进程。虽然它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 <code>fork()</code> 返回的值是不同的。父进程获得的返回值是新创建子进程的 <code>PID</code>，而子进程获得的返回值是 <code>0</code>。这个差别非常重要，因为这样就很容易编写代码处理两种不同的情况。</p>
<p>这段程序的输出不是确定的，在上面的例子中，父进程先运行并输出信息。在其他情况下，子进程可能先运行，会有下面的输出结果：</p>
<pre tabindex="0"><code>hello world (pid:3949)
hello, I am child (pid:3950)
hello, I am parent of 3950 (pid:3949)
</code></pre><p><code>CPU</code> 调度程序决定了某个时刻哪个进程被执行，由于 <code>CPU</code> 调度程序非常复杂，所以我们不能假设哪个进程会先运行。</p>
<h2 id="wait-系统调用"><a href="#wait-系统调用" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>wait()</code> 系统调用</h2>
<p>有时候，父进程需要等待子进程执行完毕。这项任务由 <code>wait()</code> 系统调用（或者更完整的接口 <code>waitpid()</code> ）来完成：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p2.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fork failed; exit
</span><span class="c1"></span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;fork failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// child (new process)
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// parent goes down this path (main)
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am parent of %d (wc:%d) (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>上面的代码增加了 <code>wait()</code> 调用，因此输出结果也变得确定了。因为子进程可能先运行，先于父进程输出结果。但是，如果父进程碰巧先运行，它会马上调用 <code>wait()</code>。该系统调用会在子进程运行结束后才返回。因此，即使父进程先运行，它也会等待子进程运行完毕，然后 <code>wait()</code> 返回，接着父进程才输出自己的信息。</p>
<pre tabindex="0"><code>hello world (pid:4297)
hello, I am child (pid:4298)
hello, I am parent of 4298 (wc:4298) (pid:4297)
</code></pre><h2 id="最后是-exec-系统调用"><a href="#最后是-exec-系统调用" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>最后是 <code>exec()</code> 系统调用</h2>
<p><code>exec()</code> 系统调用可以让子进程执行与父进程不同的程序。例如，在 <code>p2.c</code> 中调用 <code>fork()</code>，在运行相同程序的拷贝时有用。使用 <code>exec()</code> 可以运行不同的程序。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p3.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fork failed; exit
</span><span class="c1"></span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;fork failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// child (new process)
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am child (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">myargs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&#34;wc&#34;</span><span class="p">);</span> <span class="c1">// program: &#34;wc&#34; (word count)
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&#34;p3.c&#34;</span><span class="p">);</span> <span class="c1">// argument: file to count
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// marks end of array
</span><span class="c1"></span>        <span class="n">execvp</span><span class="p">(</span><span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">myargs</span><span class="p">);</span> <span class="c1">// runs word count
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;this shouldn&#39;t print out&#34;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// parent goes down this path (main)
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, I am parent of %d (wc:%d) (pid:%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>子进程调用 <code>execvp()</code> 来运行字符计数程序 <code>wc</code>。实际上，它针对源代码文件 <code>p3.c</code> 运行 <code>wc</code>，从而告诉我们该文件有多少行、多少单词，以及多少字节。</p>
<pre tabindex="0"><code>hello world (pid:4742)
hello, I am child (pid:4743)
 26 119 930 p3.c
hello, I am parent of 4743 (wc:4743) (pid:4742)
</code></pre><p>给定可执行程序的名称（如 <code>wc</code>）及需要的参数（如 <code>p3.c</code>）后，<code>exec()</code> 会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 <code>argv</code> 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 <code>p3</code>）替换为不同的运行程序（<code>wc</code>）。子进程执行 <code>exec()</code> 之后，几乎就像 <code>p3.c</code> 从未运行过一样。对 <code>exec()</code> 的成功调用永远不会返回。</p>
<h2 id="为什么这样设计-api"><a href="#为什么这样设计-api" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>为什么这样设计 <code>API</code></h2>
<p>分离 <code>fork()</code> 和 <code>exec()</code> 的做法在构建 <code>UNIX shell</code> 时非常有用，因为这给了 <code>shell</code> 在 <code>fork</code> 之后 <code>exec</code> 之前运行代码的机会，这些代码可以在运行新程序前改变环境。</p>
<p><code>shell</code> 是一个用户程序，它首先显示一个提示符，然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，<code>shell</code> 可以在文件系统中找到这个可执行程序，调用 <code>fork()</code> 创建新进程，并调用 <code>exec()</code> 的某个变体来执行这个可执行程序，调用 <code>wait()</code> 等待该命令完成。子进程执行结束后，<code>shell</code> 从 <code>wait()</code> 返回并再次输出一个提示符，等待用户输入下一条命令。</p>
<p><code>fork()</code> 和 <code>exec()</code> 的分离，让 <code>shell</code> 可以方便地实现很多有用的功能。比如：</p>
<pre tabindex="0"><code>$ wc p3.c &gt; newfile.txt
</code></pre><p>在上面的例子中，<code>wc</code> 的输出结果被重定向到文件 <code>newfile.txt</code> 中。<code>shell</code> 实现结果重定向的方式也很简单，当完成子进程的创建后，<code>shell</code> 在调用 <code>exec()</code> 之前先关闭了标准输出，打开了文件 <code>newfile.txt</code>。这样，即将运行的程序 <code>wc</code> 的输出结果就被发送到该文件，而不是打印在屏幕上。</p>
<p>下面的程序展示了重定向的工作原理。具体来说，<code>UNIX</code> 系统从 <code>0</code> 开始寻找可以使用的文件描述符。在这个例子中，<code>STDOUT_FILENO</code> 将成为第一个可用的文件描述符，因此在 <code>open()</code> 被调用时，得到赋值。然后子进程向标准输出文件描述符的写入，都会被透明地转向新打开的文件而非屏幕。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p4.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fork failed; exit
</span><span class="c1"></span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;fork failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// child: redirect standard output to a file
</span><span class="c1"></span>
        <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
        <span class="n">open</span><span class="p">(</span><span class="s">&#34;./p4.output&#34;</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>

        <span class="kt">char</span> <span class="o">*</span><span class="n">myargs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// now exec &#34;wc&#34;...
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&#34;wc&#34;</span><span class="p">);</span> <span class="c1">// program: &#34;wc&#34; (word count)
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&#34;p4.c&#34;</span><span class="p">);</span> <span class="c1">// argument: file to count
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// marks end of array
</span><span class="c1"></span>        <span class="n">execvp</span><span class="p">(</span><span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">myargs</span><span class="p">);</span> <span class="c1">// runs word count
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// parent goes down this path (original process)
</span><span class="c1"></span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">wc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>运行结果：</p>
<pre tabindex="0"><code>$ ./p4
$ cat p4.output
 30 120 932 p4.c
</code></pre><p>首先，当运行 <code>p4</code> 程序后，好像什么也没有发生。<code>shell</code> 只是打印了命令提示符，等待用户的下一个命令。但事实并非如此，<code>p4</code> 确实调用了 <code>fork()</code> 来创建新的子进程，之后调用 <code>execvp()</code> 来执行 <code>wc</code>。屏幕上没有看到输出，是由于结果被重定向到文件 <code>p4.output</code>。其次，当用 <code>cat</code> 命令打印输出文件时，能看到运行 <code>wc</code> 的所有预期输出。</p>
<p><code>UNIX</code> 管道也是用类似的方式实现的，但用的是 <code>pipe()</code> 系统调用。在这种情况下，一个进程的输出被链接到了一个内核管道上（队列），另一个进程的输入也被连接到了同一个管道上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。比如通过将 <code>grep</code>、<code>wc</code> 命令用管道连接可以完成从一个文件中查找某个词，并统计其出现次数的功能：<code>grep -o foo file | wc -l</code>。</p>
<h2 id="其他-api"><a href="#其他-api" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>其他 <code>API</code></h2>
<p>除了 <code>fork()</code>、<code>exec()</code> 和 <code>wait()</code> 之外，在 <code>UNIX</code> 中还有其他许多与进程交互的方式。比如可以通过 <code>kill()</code> 系统调用向进程发送信号，包括要求进程睡眠、终止或其他有用的指令。实际上，整个信号子系统提供了一套丰富的向进程传递外部事件的途径，包括接受和执行这些信号。</p>
<p>此外还有许多非常有用的命令行工具。比如通过 <code>ps</code> 命令来查看当前在运行的进程。工具 <code>top</code> 展示当前系统中进程消耗 <code>CPU</code> 或其他资源的情况。</p>
<h1 id="机制受限直接执行"><a href="#机制受限直接执行" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>机制：受限直接执行</h1>
<p>虚拟化 <code>CPU</code>——操作系统需要以某种方式让许多任务共享物理 <code>CPU</code>，让它们看起来像是同时运行。</p>
<p>基本思路——运行一个进程一段时间，然后运行另一个进程，如此轮换。通过以这种方式时分共享 <code>CPU</code>，就实现了虚拟化。</p>
<p>挑战：</p>
<p>性能——如何在不增加系统开销的情况下实现虚拟化？</p>
<p>控制权——如何在高效地运行进程的同时保留对 <code>CPU</code> 的控制？控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。</p>
<h2 id="基本技巧受限直接执行"><a href="#基本技巧受限直接执行" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>基本技巧：受限直接执行</h2>
<p>这个概念的“直接执行”部分很简单：只需直接在 <code>CPU</code> 上运行程序即可。</p>
<p>因此，当 <code>OS</code> 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存中，找到程序入口，跳转到那里，并开始运行用户的代码。</p>
<p>下图展示了这种基本的直接执行协议（没有任何限制），使用正常的调用并返回跳转到程序的main()，并在稍后回到内核。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-005.png" alt=""></p>
<p>但是，这种方法在虚拟化 <code>CPU</code> 时会产生一些问题。如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？</p>
<p>当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化 <code>CPU</code> 所需的时分共享？</p>
<h2 id="问题1受限制的操作"><a href="#问题1受限制的操作" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>问题1：受限制的操作</h2>
<p>直接执行的明显优势是快速。该程序直接在硬件 <code>CPU</code> 上运行，但是，如果进程希望执行某种受限的操作（如向磁盘发出 <code>I/O</code> 请求或获得如 <code>CPU</code> 或内存更多的系统资源）该怎么办？</p>
<p>一种方法是让所有进程做所有它想做的事情。但是我们希望一个进程必须能够执行 <code>I/O</code> 和其他一些受限制的操作，但又不能让进程完全控制系统。</p>
<p>更好的方法是引入一种新的处理器模式，称为用户模式。在用户模式下运行的代码会受到限制。</p>
<p>在用户模式下运行时，进程不能执行某些受限制的指令，否则会导致处理器引发异常，操作系统可能会终止该进程。</p>
<p>在内核模式下，运行的代码可以进行一些特权操作，操作系统（或内核）就以这种模式运行。</p>
<p>如果用户希望执行某种特权操作（例如从磁盘读取），那应该怎么做？为了实现这一点，几乎所有的现代硬件都提供了用户程序执行系统调用的能力。例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。</p>
<p>要执行系统调用，程序必须执行特殊的陷阱指令。该指令跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p>
<p>硬件通过提供不同的执行模式来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源。还提供了陷入内核和从陷阱返回到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表在内存中的位置。执行陷阱时，硬件需要小心，因为它必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。例如，在 <code>x86</code> 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序。</p>
<p>操作系统在启动时会设置陷阱表，以便告诉硬件在发生某些异常事件时要运行哪些代码。操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器，并且硬件知道在发生系统调用和其他异常事件时要跳转到哪段代码。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-006.png" alt=""></p>
<p>受限直接执行协议有两个阶段。第一个阶段（在系统引导时），内核初始化陷阱表，并且 <code>CPU</code> 记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体显示）。第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容，这会将 <code>CPU</code> 切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从 <code>main()</code> 返回。这通常会返回到一些存根代码，它将正确退出该程序。随后，操作系统清理现场，任务完成。</p>
<h2 id="问题2在进程间切换"><a href="#问题2在进程间切换" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>问题2：在进程间切换</h2>
<p>接下来我们面临的一个关键问题是，操作系统如何重新获得 <code>CPU</code> 的控制权，以便它可以在进程之间切换？</p>
<h3 id="协作方式等待系统调用"><a href="#协作方式等待系统调用" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>协作方式：等待系统调用</h3>
<p>过去某些系统采用协作方式。在这种风格下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃 <code>CPU</code>，以便操作系统可以决定运行其他任务。然而，在协作方式中，当进程陷入无限循环时，唯一的办法就是重新启动计算机。</p>
<h3 id="非协作方式操作系统进行控制"><a href="#非协作方式操作系统进行控制" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>非协作方式：操作系统进行控制</h3>
<p>如果进程不协作，操作系统可以通过时钟中断获得 <code>CPU</code> 的控制权。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序会运行。此时，操作系统重新获得 <code>CPU</code> 的控制权，因此可以停止当前进程，并启动另一个进程。需要注意的是，操作系统在启动时必须通知硬件哪些代码在发生时钟中断时运行。在启动过程中，操作系统也必须启动时钟（特权操作）。一旦时钟开始运行，操作系统就感到安全了，因为控制权最终会归还给它，因此操作系统可以自由运行用户程序。时钟也可以关闭（也是特权操作）。硬件在发生中断时有一定的责任，尤其是在中断发生时，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。这一组操作与硬件在显式系统调用陷入内核时的行为非常相似，其中各种寄存器因此被保存（进入内核栈），因此从陷阱返回指令可以容易地恢复。</p>
<h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>保存和恢复上下文</h3>
<p>操作系统已经重新获得 <code>CPU</code> 控制权后，必须决定是继续运行当前正在运行的进程，还是切换到另一个进程。这个决定是由调度程序做出的，它是操作系统的一部分。如果决定进行切换，<code>OS</code> 就会执行一些底层代码，即所谓的上下文切换。简单来讲，操作系统在上下文切换时要做的就是为当前正在执行的进程保存一些寄存器的值，并为即将执行的进程恢复一些寄存器的值。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-007.png" alt=""></p>
<p>在此协议中，有两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候，此时运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B，内核寄存器将被操作系统明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。</p>
<p>为了更好地了解如何实现这种切换，下面给出了xv6的上下文切换代码。<code>context</code> 结构 <code>old</code> 和 <code>new</code> 分别在老的和新的进程的进程结构中。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="c1"># void swtch(struct context **old, struct context *new);</span>
<span class="c1">#</span>
<span class="c1"># Save current register context in old</span>
<span class="c1"># and then load register context from new.</span>
<span class="n">.globl</span> <span class="n">swtch</span>
<span class="n">swtch</span><span class="o">:</span>
  <span class="c1"># Save old registers</span>
  <span class="n">movl</span> <span class="m">4</span><span class="p">(</span><span class="o">%esp), %</span><span class="n">eax</span> <span class="c1"># put old ptr into eax</span>
  <span class="n">popl</span> <span class="m">0</span><span class="p">(</span><span class="o">%eax)        # save the old IP
</span><span class="o"> movl %</span><span class="n">esp</span><span class="p">,</span> <span class="m">4</span><span class="p">(</span><span class="o">%eax) # and stack
</span><span class="o"> movl %</span><span class="n">ebx</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="o">%eax) # and other registers
</span><span class="o"> movl %</span><span class="n">ecx</span><span class="p">,</span> <span class="m">12</span><span class="p">(</span><span class="o">%eax)
</span><span class="o"> movl %</span><span class="n">edx</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="o">%eax)
</span><span class="o"> movl %</span><span class="n">esi</span><span class="p">,</span> <span class="m">20</span><span class="p">(</span><span class="o">%eax)
</span><span class="o"> movl %</span><span class="n">edi</span><span class="p">,</span> <span class="m">24</span><span class="p">(</span><span class="o">%eax)
</span><span class="o"> movl %</span><span class="n">ebp</span><span class="p">,</span> <span class="m">28</span><span class="p">(</span><span class="o">%eax)
</span><span class="o">
</span><span class="o"> # Load new registers
</span><span class="o"> movl 4(%</span><span class="n">esp</span><span class="p">),</span> <span class="o">%eax # put new ptr into eax
</span><span class="o"> movl 28(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%ebp # restore other registers
</span><span class="o"> movl 24(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%edi
</span><span class="o"> movl 20(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%esi
</span><span class="o"> movl 16(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%edx
</span><span class="o"> movl 12(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%ecx
</span><span class="o"> movl 8(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%ebx
</span><span class="o"> movl 4(%</span><span class="n">eax</span><span class="p">),</span> <span class="o">%esp  # stack is switched here
</span><span class="o"> pushl 0(%</span><span class="n">eax</span><span class="p">)</span>       <span class="c1"># return addr put in place</span>
 <span class="n">ret</span>                 <span class="c1"># finally return into new ctxt</span>
</code></pre></td></tr></table></div>
</div>
</div><h2 id="担心并发吗"><a href="#担心并发吗" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>担心并发吗</h2>
<p>在系统调用期间发生时钟中断时会发生什么？</p>
<p>在处理一个中断时发生另一个中断，会发生什么？</p>
<p>操作系统可能简单地决定，在中断处理期间禁止中断，但是禁止中断时间过长可能导致丢失中断。</p>
<p>操作系统还开发了许多复杂的加锁方案，以保护内部数据结构的并发访问。这使得多个活动可以同时在内核中进行，特别适合用于多处理器。</p>
<h1 id="进程调度介绍"><a href="#进程调度介绍" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>进程调度：介绍</h1>
<h2 id="工作负载假设"><a href="#工作负载假设" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>工作负载假设</h2>
<p>探讨可能的调度策略之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载。确定工作负载是构建调度策略的关键部分。这里做的工作负载假设是不切实际的，但我们会逐渐放宽这些假定，并最终开发出一个完全可操作的调度准则。</p>
<p>我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：</p>
<p>1）每一个工作运行相同的时间；</p>
<p>2）所有的工作同时到达；</p>
<p>3）一旦开始，每个工作保持运行直到完成；</p>
<p>4）所有的工作只使用 <code>CPU</code>（即没有 <code>I/O</code> 操作）；</p>
<p>5）每个工作的运行时间是已知的。</p>
<h2 id="调度指标"><a href="#调度指标" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>调度指标</h2>
<p>除了做出工作负载假设之外，还需要一个东西能让我们比较不同的调度策略：调度指标。任务的周转时间定义为任务完成时间减去任务到达系统的时间：</p>
<p><code>T_周转时间 = T_完成时间 - T_到达时间</code></p>
<p>如果假设所有的任务在同一时间到达，那么 <code>T_到达时间 = 0</code>，因此 <code>T_周转时间 = T_完成时间</code>。</p>
<p>注意到，周转时间是一个性能指标，而另一个有趣的指标是公平。性能和公平在调度系统中往往是矛盾的。例如，调度程序可以优化性能，但代价是以阻止一些任务运行，这就降低了公平。</p>
<h2 id="先进先出fifo"><a href="#先进先出fifo" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>先进先出（<code>FIFO</code>）</h2>
<p>最基本的算法被称为先进先出调度，有时候也称为先到先服务。它很简单，易于实现，而且对于目前的假设效果不错。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-008.png" alt=""></p>
<p>假设 <code>3</code> 个工作 <code>A</code>、<code>B</code> 和 <code>C</code> 在大致相同的时间到达系统。因为 <code>FIFO</code> 必须将某个工作放在前面，所以我们假设当它们都同时到达时，<code>A</code> 比 <code>B</code> 早一点点，然后 <code>B</code> 比 <code>C</code> 早到达一点点。假设每个工作运行 <code>10s</code>，从图上可以看出，<code>A</code> 在 <code>10s</code> 时完成，<code>B</code> 在 <code>20s</code> 时完成，<code>C</code> 在 <code>30s</code> 时完成。因此，这 <code>3</code> 个任务的平均周转时间就是 <code>(10 + 20 + 30) / 3 = 20s</code>。</p>
<p>现在，我们放宽假设 <code>1</code>，每个任务的运行时间不再相同。这种情况下FIFO的表现如何？具体来说，我们再次假设 <code>3</code> 个任务（<code>A</code>、<code>B</code> 和 <code>C</code>），但这次 <code>A</code> 运行 <code>100s</code>，而 <code>B</code> 和 <code>C</code> 运行 <code>10s</code>。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-009.png" alt=""></p>
<p>如图所示，<code>A</code> 先运行 <code>100s</code>，<code>B</code> 或 <code>C</code> 才有机会运行。因此，系统的平均周转时间是比较高的 <code>(100 + 110 + 120) / 3 = 110s</code>。这个问题通常被称为护航效应，一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。</p>
<h2 id="最短任务优先sjf"><a href="#最短任务优先sjf" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>最短任务优先（<code>SJF</code>）</h2>
<p>事实上，我们一个非常简单的方法来解决护航问题。这个新的调度准则被称为最短任务优先，即先运行最短的任务，然后是次短的任务，以此类推。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-010.png" alt=""></p>
<p>还是上面的例子，但这次以 <code>SJF</code> 作为调度策略。上图展示的是运行 <code>A</code>、<code>B</code> 和 <code>C</code> 的结果。通过在 <code>A</code> 之前运行 <code>B</code> 和 <code>C</code>，<code>SJF</code> 将平均周转时间从 <code>110s</code> 降低到 <code>(10 + 20 + 120) / 3 = 50s</code>。在所有工作同时到达的情况下，可以证明 <code>SJF</code> 是一个最优的调度算法。</p>
<p>现在，让我们放宽假设 <code>2</code>，即工作可以随时到达，而不是同时到达。假设 <code>A</code> 在 <code>t = 0</code> 时到达，且需要运行 <code>100s</code>。而 <code>B</code> 和 <code>C</code> 在 <code>t = 10</code> 时到达，且各需要运行 <code>10s</code>。使用 <code>SJF</code>，可以得到如下所示的调度。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-011.png" alt=""></p>
<p>从图中可以看出，即使 <code>B</code> 和 <code>C</code> 在 <code>A</code> 之后不久到达，它们仍然被迫等到 <code>A</code> 完成，从而遭遇同样的护航问题。这 <code>3</code> 项工作的平均周转时间为 <code>(100 + (110 − 10) + (120 − 10)) / 3 = 103.33s</code>。</p>
<h2 id="最短完成时间优先stcf"><a href="#最短完成时间优先stcf" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>最短完成时间优先（<code>STCF</code>）</h2>
<p>为了解决这个问题，需要放宽假设 <code>3</code>（工作必须保持运行直到完成）。也就是说，当 <code>B</code> 和 <code>C</code> 到达时，调度程序可以做其他事情：它可以抢占工作 <code>A</code>，并决定运行另一个工作，或许稍后继续工作 <code>A</code>，根据我们的定义，<code>SJF</code> 是一种非抢占式调度程序，因此还是存在护航问题。</p>
<p>通过向SJF添加抢占，我们可以得到最短完成时间优先调度程序。每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。因此，在我们的例子中，<code>STCF</code> 将抢占 <code>A</code> 并运行 <code>B</code> 和 <code>C</code> 以完成。只有在它们完成后，才能调度 <code>A</code> 的剩余时间。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-012.png" alt=""></p>
<p>根据上图，<code>3</code> 项工作的平均周转时间是 <code>((20 − 10) + (30 − 10) + 120) / 3 = 50s</code>。基于新的假设，可证明 <code>STCF</code> 是最优的。</p>
<h2 id="新度量指标响应时间"><a href="#新度量指标响应时间" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>新度量指标：响应时间</h2>
<p>如果我们知道任务长度，任务只使用 <code>CPU</code>，且唯一的衡量是周转时间，那么 <code>STCF</code> 将是一个很好的策略。然而，引入分时系统改变了这一切。现在，用户将会坐在终端前面，同时也要求系统的交互性好。因此，一个新的度量标准诞生了：响应时间，它定义为任务到达系统到首次运行该任务的时间：</p>
<p><code>T_响应时间 = T_首次运行 − T_到达时间</code></p>
<p>显然，<code>STCF</code> 和相关方法在响应时间上并不是很好。如果 <code>3</code> 个工作同时到达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时间，但对于响应时间和交互性是相当糟糕的。</p>
<h2 id="轮转rr"><a href="#轮转rr" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>轮转（<code>RR</code>）</h2>
<p>为了提高响应时间，我们将引入轮转调度。其基本思想很简单：在一个时间片内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束，它反复执行，直到所有任务完成。注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每 <code>10ms</code> 中断一次，则时间片可以是 <code>10ms</code>、<code>20ms</code> 或 <code>10ms</code> 的任何其他倍数。</p>
<p>假设3个任务 <code>A</code> 、 <code>B</code> 和 <code>C</code> 在系统中同时到达，并且它们都希望运行 <code>5s</code>。如下所示，SJF调度程序必须运行完当前任务才可运行下一个任务，其平均响应时间是 <code>(0 + 5 + 10) / 3 = 5s</code>。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-013.png" alt=""></p>
<p>相比之下，<code>1s</code> 时间片的 <code>RR</code> 可以快速地循环工作，其平均响应时间为 <code>(0 + 1 + 2) / 3 = 1s</code>。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-014.png" alt=""></p>
<p>显然，时间片长度对于 <code>RR</code> 是至关重要的。时间片越短，<code>RR</code> 在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销上下文切换成本，而又不会使系统不及时响应。</p>
<p>摊销：通过减少成本的频度（即：执行较少的操作），系统的总成本就会降低。例如：如果时间片设置为 <code>10ms</code>，并且上下文切换时间为 <code>1ms</code>，大约会浪费 <code>10%</code> 的时间用于上下文切换。为了摊销这个成本，可以把时间片长度增加到 <code>100ms</code>，则只有不到 <code>1%</code> 的时间会用于上下文切换。</p>
<p>我们只考虑了响应时间，没考虑周转时间，如果计算 <code>RR</code> 的周转时间，<code>A</code> 为13，<code>B</code> 为14，<code>C</code> 为 <code>15</code>，平均 <code>14</code>。而 <code>SJF</code> 的周转时间为，<code>A</code> 为5，<code>B</code> 为 <code>10</code>，<code>C</code> 为 <code>15</code>，平均 <code>10</code>。此时 <code>RR</code> 虽然响应时间较好，但是周转时间较差。</p>
<p>到目前为止。有两类调度程序：</p>
<p>1）<code>SJF</code>、<code>STCF</code> 优化了周转时间，但是响应时间——交互性不好；</p>
<p>2）<code>RR</code> 优化了响应时间，但是周转时间不好。</p>
<h2 id="结合-io"><a href="#结合-io" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>结合 <code>I/O</code></h2>
<p>接下来我们放宽假设 <code>4</code>，现在所有的程序都会执行 <code>I/O</code>，调度程序显然要在工作发起 <code>I/O</code> 请求时做出决定，因为当前正在运行的作业在 <code>I/O</code> 期间不会使用 <code>CPU</code>，它被阻塞等待 <code>I/O</code> 完成。如果将 <code>I/O</code> 发送到硬盘驱动器，则进程可能会被阻塞几毫秒或更长时间。因此，这时调度程序应该在 <code>CPU</code> 上安排另一项工作。</p>
<p>调度程序还必须在 <code>I/O</code> 完成时做出决定。发生这种情况时，会产生中断，操作系统运行并将发出 <code>I/O</code> 的进程从阻塞状态移回就绪状态。当然，它甚至可以决定在那个时候运行该项工作。操作系统应该如何处理每项工作？</p>
<p>假设有两项工作 <code>A</code> 和 <code>B</code>，每项工作需要50ms的 <code>CPU</code> 时间。但是 <code>A</code> 先运行 <code>10ms</code>，然后发出 <code>I/O</code> 请求（假设 <code>I/O</code> 每个都需要 <code>10ms</code>），而 <code>B</code> 只是使用 <code>CPU</code>  50ms，不执行 <code>I/O</code>，调度程序先运行 <code>A</code>，然后运行 <code>B</code>，</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-015.png" alt=""></p>
<p>毫无疑问，上图所示的调度是非常糟糕的。</p>
<p>常见的方法是将 <code>A</code> 的每个 <code>10ms</code> 的子工作视为一项独立的工作。因此，当系统启动时，它的选择是调度 <code>10ms</code> 的 <code>A</code>，还是50ms的 <code>B</code>，<code>STCF</code> 会选择较短的 <code>A</code>，然后，<code>A</code> 的工作已完成，只剩下 <code>B</code>，并开始运行。然后提交 <code>A</code> 的一个新子工作，它抢占 <code>B</code> 并运行 <code>10ms</code>。这样做可以实现重叠，一个进程在等待另一个进程的 <code>I/O</code> 完成时使用 <code>CPU</code>，系统因此得到更好的利用。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-016.png" alt=""></p>
<h2 id="无法预知"><a href="#无法预知" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>无法预知</h2>
<p>有了应对 <code>I/O</code> 的基本方法，我们来到最后的假设 <code>5</code>：调度程序知道每个工作的长度。如前所述，这可能是可以做出的最糟糕的假设。事实上，操作系统通常不知道每个作业的长度。因此，我们利用最近的历史预测未来，从而解决这个问题。</p>
<h1 id="调度多级反馈队列"><a href="#调度多级反馈队列" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>调度：多级反馈队列</h1>
<p>多级反馈队列（简称 <code>MLFQ</code>）需要解决两方面的问题。首先它要优化周转时间，这可以通过优先执行较短的工作来实现。然而，操作系统常常不知道工作要运行多久，而这又是 <code>SJF</code> 等算法所必需的。其次，<code>MLFQ</code> 希望给用户提供较好的交互体验，因此需要降低响应时间。然而，轮转调度虽然降低了响应时间，周转时间却很差。</p>
<p>所以这里的问题是：通常我们对进程一无所知，应该如何构建调度程序来实现这些目标？调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策？</p>
<h2 id="多级反馈队列基本规则"><a href="#多级反馈队列基本规则" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>多级反馈队列：基本规则</h2>
<p>为了构建这样的调度程序，将介绍多级消息队列背后的基本算法。</p>
<p><code>MLFQ</code> 中有许多独立的队列，每个队列有不同的优先级。任何时刻，一个工作只能存在于一个队列中。<code>MLFQ</code> 总是优先执行较高优先级的工作（即那些在较高级队列中的工作）。</p>
<p>每个队列中可能会有多个工作，它们具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。</p>
<p><code>MLFQ</code> 没有为每个工作指定不变的优先顺序，而是根据观察到的行为调整他的优先级。例如：</p>
<p>如果一个工作频繁放弃 <code>CPU</code> 等待键盘操作，我们就可以视他为交互型进程，并提高他的优先级。</p>
<p>如果一个工作长时间占用 <code>CPU</code>，我们就可以视他为计算密集型进程，并降低他的优先级。</p>
<p>至此，我们得到了 <code>MLFQ</code> 的两条基本规则：</p>
<p>规则1：如果 <code>A</code> 的优先级大于 <code>B</code> 的优先级，运行 <code>A</code> 不运行 <code>B</code></p>
<p>规则2：如果 <code>A</code> 的优先级等于 <code>B</code> 的优先级，轮转运行 <code>A</code> 和 <code>B</code></p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-017.png" alt=""></p>
<p>上图中，最高优先级有两个工作（<code>A</code> 和 <code>B</code>），工作 <code>C</code> 位于中等优先级，而 <code>D</code> 的优先级最低。按刚才介绍的基本规则，由于 <code>A</code> 和 <code>B</code> 有最高优先级，调度程序将交替的调度他们，而 <code>C</code> 和 <code>D</code> 永远都没有机会运行，除非 <code>A</code> 和 <code>B</code> 已经完成。</p>
<h2 id="尝试1如何改变优先级"><a href="#尝试1如何改变优先级" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>尝试1：如何改变优先级</h2>
<p>我们知道，有两种类型的进程，我们要对其进行不同的优先级调整。</p>
<p><code>MLFQ</code> 在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。下面是我们第一次尝试优先级调整算法。</p>
<p>规则3：工作进入系统时，放在最高优先级（最上层）队列</p>
<p>规则4a：工作用完整个时间片后，降低其优先级（移入低一级队列）</p>
<p>规则4b：如果工作在其时间片以内主动释放 <code>CPU</code>，则优先级不变</p>
<h3 id="实例1单个长工作"><a href="#实例1单个长工作" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>实例1：单个长工作</h3>
<p>假如系统中有一个需要长时间运行的工作，我们看看使用当前的 <code>MLFQ</code> 调度会发生什么。下图展示了在一个有3个队列的调度程序中，随着时间的推移，这个工作的运行情况。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-018.png" alt=""></p>
<p>从这个例子可以看出，该工作首先进入最高优先级（<code>Q2</code>）。执行一个 <code>10ms</code> 的时间片后，调度程序将工作的优先级减 <code>1</code>，因此进入 <code>Q1</code>。在 <code>Q1</code> 执行一个时间片后，最终降低优先级进入系统的最低优先级（<code>Q0</code>），一直留在那里。</p>
<h3 id="实例2来了一个短工作"><a href="#实例2来了一个短工作" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>实例2：来了一个短工作</h3>
<p>再看一个较复杂的例子，看看 <code>MLFQ</code> 如何近似 <code>SJF</code>。在这个例子中，有两个工作：<code>A</code> 是一个长时间运行的 <code>CPU</code> 密集型工作，<code>B</code> 是一个运行时间很短的交互型工作。假设 <code>A</code> 执行一段时间后 <code>B</code> 到达。会发生什么呢？</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-019.png" alt=""></p>
<p>上图展示了这种场景的结果。<code>A</code>（用黑色表示）在最低优先级队列执行（长时间运行的 <code>CPU</code> 密集型工作都这样）。<code>B</code>（用灰色表示）在时间为 <code>100ms</code> 时到达，并被加入最高优先级队列。由于它的运行时间很短（只有 <code>20ms</code>），经过两个时间片，在被移入最低优先级队列之前，<code>B</code> 执行完毕。然后 <code>A</code> 继续运行（在低优先级）。</p>
<p>通过这个例子，我们可以体会到这个算法的一个主要目标：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，<code>MLFQ</code> 近似于 <code>SJF</code>。</p>
<h3 id="实例3如果有-io-呢"><a href="#实例3如果有-io-呢" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>实例3：如果有 <code>I/O</code> 呢</h3>
<p>根据上述规则 <code>4b</code>，如果进程在时间片用完之前主动放弃 <code>CPU</code>，则保持它的优先级不变。这条规则的意图很简单：假设交互型工作中有大量的 <code>I/O</code> 操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 <code>CPU</code>。在这种情况下，我们不想处罚它，只是保持它的优先级不变。</p>
<p>下图展示了这个运行过程，交互型工作 <code>B</code>（用灰色表示）每执行 <code>1ms</code> 便需要进行 <code>I/O</code> 操作，它与长时间运行的工作 <code>A</code>（用黑色表示）竞争 <code>CPU</code>。<code>MLFQ</code> 算法保持 <code>B</code> 在最高优先级，因为 <code>B</code> 总是让出 <code>CPU</code>。如果 <code>B</code> 是交互型工作，<code>MLFQ</code> 就进一步实现了它的目标，让交互型工作快速运行。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-020.png" alt=""></p>
<h3 id="当前-mlqf-的一些问题"><a href="#当前-mlqf-的一些问题" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>当前 <code>MLQF</code> 的一些问题</h3>
<p>至此，我们有了基本的 <code>MLFQ</code>。它看起来似乎相当不错，长工作之间可以公平地分享 <code>CPU</code>，又能给短工作或交互型工作很好的响应时间。然而，这种算法有一些非常严重的缺点。</p>
<p>首先，会有饥饿问题。如果系统有“太多”交互型工作，就会不断占用 <code>CPU</code>，导致长工作永远无法得到 <code>CPU</code>。即使在这种情况下，我们也希望这些长工作也能有所进展。</p>
<p>其次，某些用户会用一些手段欺骗调度程序，让它给予进程远超公平的资源。例如，上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 <code>I/O</code> 操作（比如访问一个无关的文件），从而主动释放 <code>CPU</code>。如此便可以保持在高优先级，占用更多的 <code>CPU</code> 时间。做得好时（比如，每运行 <code>99%</code> 的时间片时间就主动放弃一次 <code>CPU</code>），工作可以几乎独占 <code>CPU</code>。</p>
<p>最后，一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间表现为一个交互型的进程。用目前的方法，它不会享受系统中其他交互型工作的待遇。</p>
<h2 id="尝试2提升优先级"><a href="#尝试2提升优先级" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>尝试2：提升优先级</h2>
<p>我们首先来尝试避免饥饿问题。要让 <code>CPU</code> 密集型工作也能取得一些进展，一个简单的思路是周期性地提升所有工作的优先级，最简单的实现就是将所有工作一股脑儿地扔到最高优先级队列。于是，我们有了以下规则。</p>
<p>规则5：经过一段时间 <code>S</code>，就将系统中所有工作重新加入最高优先级队列</p>
<p>新规则一下解决了两个问题。首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享 <code>CPU</code>，从而最终获得执行。其次，如果一个 <code>CPU</code> 密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。</p>
<p>在这种场景下，我们展示长工作与两个交互型短工作竞争 <code>CPU</code> 时的行为。下图左边没有优先级提升，长工作在两个短工作到达后被饿死。右边每 <code>50ms</code> 就有一次优先级提升（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 <code>50ms</code> 就被提升到最高优先级，从而定期获得执行。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-021.png" alt=""></p>
<p>显然，添加时间段引入了新的问题：<code>S</code> 的值该如何设定？如果设置得太高，长工作就会饥饿；如果设置得太低，交互型工作又得不到合适的 <code>CPU</code> 时间比例。</p>
<h2 id="尝试3更好的计时方式"><a href="#尝试3更好的计时方式" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>尝试3：更好的计时方式</h2>
<p>现在还有一个问题没有解决，如何阻止调度程序被愚弄？可以看出，这里的元凶是规则 <code>4a</code> 和 <code>4b</code>。</p>
<p>为了解决这个问题，我们可以为 <code>MLFQ</code> 的每层队列提供更完善的 <code>CPU</code> 计时方式（<code>accounting</code>）。</p>
<p>调度程序记录每一个进程在某一层队列中消耗的总时间，如果这个时间超过了该层队列设置的时间配额，那么就降低该进程的优先级，将它降到低一级别的队列中去。不论它是一次用完的，还是拆成很多次用完。</p>
<p>因此，我们重写规则 <code>4a</code> 和 <code>4b</code>。</p>
<p>规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 <code>CPU</code>），就降低其优先级（移入低一级队列）。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-022.png" alt=""></p>
<p>上图对比了在规则 <code>4a</code>、<code>4b</code> 的策略下（左），以及在新的规则 <code>4</code>（右）的策略下，同样试图欺骗调度程序的进程的表现。没有规则 <code>4</code> 的保护时，进程可以在每个时间片结束前发起一次 <code>I/O</code> 操作，从而垄断 <code>CPU</code> 时间。有了这样的保护后，不论进程的 <code>I/O</code> 行为如何，都会慢慢地降低优先级，因而无法获得超过公平的 <code>CPU</code> 时间比例。</p>
<h2 id="mlfq-调优及其他问题"><a href="#mlfq-调优及其他问题" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>MLFQ</code> 调优及其他问题</h2>
<p>关于 <code>MLFQ</code> 调度算法还有一些问题。其中一个大问题是如何配置一个调度程序？例如：</p>
<p>配置多少队列？</p>
<p>每一层队列的时间片配置多大？</p>
<p>为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</p>
<p>这些问题都没有显而易见的答案，只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p>
<p>例如，大多数的 <code>MLFQ</code> 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 <code>10ms</code> 或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是 <code>CPU</code> 密集型工作，配置更长的时间片会取得更好的效果。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-023.png" alt=""></p>
<p><code>Solaris</code> 的 <code>MLFQ</code> 实现很容易配置，他提供一组表方便管理员进行配置。</p>
<p>其他一些 <code>MLFQ</code> 实现没有用表，甚至没用本章中提到的规则，有些采用数学公式来调整优先级。例如 <code>FreeBSD</code>。</p>
<p>许多变体也有我们没有提到的特征。例如，有些变体将最高优先队列留给操作系统使用，因此通常用户工作无法得到系统最高优先级。有些变体允许用户给出优先级设置的建议，比如通过命令行工具 <code>nice</code>。</p>
<h1 id="调度比例份额"><a href="#调度比例份额" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>调度：比例份额</h1>
<h2 id="基本概念彩票数表示份额"><a href="#基本概念彩票数表示份额" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>基本概念：彩票数表示份额</h2>
<p>比例份额调度程序，有时也称为公平份额调度程序。比例份额算法认为，调度程序的最终目标是确保每个工作获得一定比例的 <code>CPU</code> 时间，而不是优化周转时间和响应时间。</p>
<p>它的基本思想很简单：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。关键的问题就是，如何设计调度程序来按比例分配 <code>CPU</code>？</p>
<h2 id="基本概念使用彩票数表示份额"><a href="#基本概念使用彩票数表示份额" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>基本概念：使用彩票数表示份额</h2>
<p>在彩票调度中，彩票数代表了进程占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p>
<p>假设有两个进程 <code>A</code> 和 <code>B</code>，<code>A</code> 拥有 <code>75</code> 张彩票，<code>B</code> 拥有 <code>25</code> 张。因此我们希望 <code>A</code> 占用 <code>75%</code> 的 <code>CPU</code> 时间，而 <code>B</code> 占用 <code>25%</code>。</p>
<p>通过不断且定时地抽取彩票，彩票调度从概率上获得这种份额比例。抽取彩票的过程很简单：调度程序知道总共的彩票数（在我们的例子中，有 <code>100</code> 张）。调度程序抽取中奖彩票，这是从 <code>0</code> 和 <code>99</code> 之间的一个数，拥有这个数对应的彩票的进程中奖。假设进程 <code>A</code> 拥有 <code>0</code> 到 <code>74</code> 共 <code>75</code> 张彩票，进程 <code>B</code> 拥有 <code>75</code> 到 <code>99</code> 的 <code>25</code> 张，中奖的彩票就决定了运行 <code>A</code> 或 <code>B</code>。调度程序然后加载中奖进程的状态，并运行它。</p>
<p>彩票调度利用了随机性，这导致了从概率上满足期望的比例。随着这两个工作运行得时间越长，它们得到的<code>CPU</code>时间比例就会越接近期望。</p>
<p>随机方法相对于传统的决策方式，至少有 <code>3</code> 点优势。</p>
<p>第一，随机方法常常可以避免奇怪的边角情况，较传统的算法（<code>LRU</code> 替换策略）可能在处理这些情况时遇到麻烦。虽然 <code>LRU</code> 通常是很好的替换算法，但在有重复序列的负载时表现非常差。随机方法就没有这种最差情况。</p>
<p>第二，随机方法很轻量，几乎不需要记录任何状态。在传统的公平份额调度算法中，记录每个进程已经获得了多少的 <code>CPU</code> 时间，需要对每个进程计时，这必须在每次运行结束后更新。而采用随机方式后每个进程只需要非常少的状态（即每个进程拥有的彩票号码）。</p>
<p>第三，随机方法很快。只要能很快地产生随机数，做出决策就很快。因此，随机方式在对运行速度要求高的场景非常适用。当然，越是需要快的计算速度，随机就会越倾向于伪随机。</p>
<h2 id="彩票机制"><a href="#彩票机制" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>彩票机制</h2>
<p>彩票调度还提供了一些机制，以不同且有效的方式来调度彩票。一种方式是利用彩票货币的概念。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p>
<p>比如，假设用户 <code>A</code> 和用户 <code>B</code> 每人拥有 <code>100</code> 张彩票。用户 <code>A</code> 有两个工作 <code>A1</code> 和 <code>A2</code>，他以自己的货币，给每个工作 <code>500</code> 张彩票（共 <code>1000</code> 张）。用户 <code>B</code> 只运行一个工作，给它 <code>10</code> 张彩票（总共 <code>10</code> 张）。操作系统将进行兑换，将 <code>A1</code> 和 <code>A2</code> 拥有的 <code>A</code> 的货币 <code>500</code> 张，兑换成全局货币 <code>50</code> 张。类似地，兑换给 <code>B1</code> 的 <code>10</code> 张彩票兑换成 <code>100</code> 张。然后会对全局彩票货币（共 <code>200</code> 张）举行抽奖，决定哪个工作运行。</p>
<pre tabindex="0"><code>ser A -&gt; 500 (A's currency) to A1 -&gt;  50 (global currency)
       -&gt; 500 (A's currency) to A2 -&gt;  50 (global currency)
User B -&gt;  10 (B's currency) to B1 -&gt; 100 (global currency)
</code></pre><p>另一个有用的机制是彩票转让。通过转让，一个进程可以临时将自己的彩票交给另一个进程。这种机制在客户端/服务端交互的场景中尤其有用，在这种场景中，客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票归还给客户端。</p>
<p>最后，彩票通胀有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 <code>CPU</code> 时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p>
<h2 id="实现"><a href="#实现" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>实现</h2>
<p>彩票调度实现起来非常简单，只需要一个随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构，以及所有彩票的总数。假设我们使用列表记录进程，下面的例子中有 <code>A</code>、<code>B</code> 和 <code>C</code> 这 <code>3</code> 个进程，每个进程有一定数量的彩票。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-024.png" alt=""></p>
<p>在做出调度决策之前，首先要从彩票总数 <code>400</code> 中选择一个随机数。假设这里选择了 <code>300</code>，然后我们遍历链表，用一个计数器帮我们找到这个数字。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// counter: used to track if we&#39;ve found the winner yet
</span><span class="c1"></span><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// winner: use some call to a random number generator to
</span><span class="c1">//         get a value, between 0 and the total # of tickets
</span><span class="c1"></span><span class="kt">int</span> <span class="n">winner</span> <span class="o">=</span> <span class="n">getrandom</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">totaltickets</span><span class="p">);</span>

<span class="c1">// current: use this to walk through the list of jobs
</span><span class="c1"></span><span class="n">node_t</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

<span class="c1">// loop until the sum of ticket values is &amp;gt; the winner
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tickets</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">winner</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// found the winner
</span><span class="c1"></span>  <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// &#39;current&#39; is the winner: schedule it...
</span></code></pre></td></tr></table></div>
</div>
</div><p>这段代码从前向后遍历进程列表，将每张票的值加到 <code>counter</code> 上，直到值超过 <code>winner</code>。这时，当前的列表元素所对应的进程就是中奖者。在我们的例子中，中奖彩票是 <code>300</code>。首先，计 <code>A</code> 的票后，<code>counter</code> 增加到 <code>100</code>。因为 <code>100</code> 小于 <code>300</code>，继续遍历。然后 <code>counter</code> 会增加到 <code>150</code>（<code>B</code> 的彩票），仍然小于 <code>300</code>，继续遍历。最后，<code>counter</code> 增加到 <code>400</code>（显然大于 <code>300</code>），因此退出遍历，<code>current</code> 指向<code>C</code>（中奖者）。</p>
<p>一个更有效率的做法是将列表项按照彩票数递减排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的节点，尤其当大多数彩票被少数进程掌握时。</p>
<h2 id="一个例子"><a href="#一个例子" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>一个例子</h2>
<p>为了更好地理解彩票调度的运行过程，我们现在简单研究一下两个互相竞争工作的完成时间，每个工作都有相同数目的 <code>100</code> 张彩票，以及相同的运行时间 <code>R</code>，我们希望两个工作在大约同时完成，由于彩票调度算法的随机性，有时一个工作会先于另一个完成。为了量化这种区别，我们定义了一个简单的不公平指标 <code>U</code>，将两个工作完成时刻相除得到 <code>U</code> 的值。比如，运行时间 <code>R</code> 为 <code>10</code>，第一个工作在时刻 <code>10</code> 完成，另一个在 <code>20</code>，那么 <code>U = 10 / 20 = 0.5</code>。如果两个工作几乎同时完成，<code>U</code> 的值将很接近于 <code>1</code>。因此，完美的公平调度程序可以做到 <code>U = 1</code>。</p>
<p>上图展示了当两个工作的运行时间从 <code>1</code> 到 <code>1000</code> 变化时，<code>30</code> 次试验的平均 <code>U</code> 值。可以看出，当工作执行时间很短时，平均不公平度非常糟糕。只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-025.png" alt=""></p>
<h2 id="如何分配彩票"><a href="#如何分配彩票" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>如何分配彩票</h2>
<p>关于彩票调度的一个关键问题就是如何为工作分配彩票？这是一个非常棘手的问题，系统的运行严重依赖于彩票的分配。假设用户自己知道如何分配，因此可以给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。然而这种方案似乎什么也没有解决——还是没有给出具体的分配策略。因此对于给定的一组工作，彩票分配的问题依然没有最佳答案。</p>
<h2 id="为什么不是确定的"><a href="#为什么不是确定的" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>为什么不是确定的</h2>
<p>虽然随机方式可以使得调度程序的简单实现（且大致正确），但偶尔并不能产生正确的比例，尤其在工作运行时间很短的情况下。由于这个原因，提出了步长调度。</p>
<p>步长调度也很简单。系统中的每个工作都有自己的步长，这个值与票数值成反比。在上面的例子中，<code>A</code>、<code>B</code>、<code>C</code> 这 <code>3</code> 个工作的票数分别是 <code>100</code>、<code>50</code> 和 <code>250</code>，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 <code>10000</code> 除以这些票数值，得到了 <code>3</code> 个进程的步长分别为 <code>100</code>、<code>200</code> 和 <code>40</code>。我们称这个值为每个进程的步长。每次进程运行后，我们会让它的计数器（称为行程值）增加它的步长，记录它的总体进展。</p>
<p>之后，调度程序使用进程的步长及行程值来确定调度哪个进程：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行后将该进程的行程值增加一个步长，伪代码：</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">current</span> <span class="o">=</span> <span class="n">remove_min</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>       <span class="c1">// pick client with minimum pass
</span><span class="c1"></span><span class="n">schedule</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>                 <span class="c1">// use resource for quantum
</span><span class="c1"></span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pass</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">stride</span><span class="p">;</span>  <span class="c1">// compute next pass using stride
</span><span class="c1"></span><span class="n">insert</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>            <span class="c1">// put back into the queue
</span></code></pre></td></tr></table></div>
</div>
</div><p>在我们的例子中，<code>3</code> 个进程（<code>A</code>、<code>B</code>、<code>C</code>）的步长值分别为 <code>100</code>、<code>200</code> 和 <code>40</code>，初始行程值都为 <code>0</code>。因此，所有进程都可能被选择执行。假设选择 <code>A</code>，<code>A</code> 执行一个时间片后，更新它的行程值为 <code>100</code>。然后运行 <code>B</code>，并更新其行程值为 <code>200</code>。最后执行 <code>C</code>，<code>C</code> 的行程值变为 <code>40</code>。这时，算法选择最小的行程值，是 <code>C</code>，执行并增加为 <code>80</code>（<code>C</code> 的步长是 <code>40</code>）。然后 <code>C</code> 再次运行（依然行程值最小），行程值增加到 <code>120</code>。现在运行 <code>A</code>，更新它的行程值为 <code>200</code>（现在与 <code>B</code> 相同）。然后 <code>C</code> 再次连续运行两次，行程值也变为 <code>200</code>。此时，所有行程值再次相等，这个过程会无限地重复下去。下表展示了一段时间内调度程序的行为。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-026.png" alt=""></p>
<p>可以看出，<code>C</code> 运行了 <code>5</code> 次、<code>A</code> 运行了 <code>2</code> 次，<code>B</code> 运行了 <code>1</code> 次，正好是票数的比例——<code>200</code>、<code>100</code> 和 <code>50</code>。彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。</p>
<p>既然有了可以精确控制的步长调度算法，为什么还要彩票调度算法呢？相比于步长调度，彩票调度的优势是不需要全局状态。假如一个新的进程在步长调度执行过程中加入系统，应该怎么设置它的行程值呢？设置成 <code>0</code> 吗？这样的话，它就独占 <code>CPU</code> 了。而彩票调度算法不需要对每个进程记录全局状态，只需要用新进程的票数更新全局的总票数就可以了。因此彩票调度算法能够更合理地处理新加入的进程。</p>
<h1 id="多处理器调度"><a href="#多处理器调度" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>多处理器调度</h1>
<p>多核 <code>CPU</code> 带来了许多困难。例如应用程序（<code>C</code> 程序）都只使用一个 <code>CPU</code>，增加了更多的 <code>CPU</code> 并没有让这类程序运行得更快。为了解决这个问题，不得不重写这些应用程序，使之能并行执行，也许使用多线程。多线程应用可以将工作分散到多个 <code>CPU</code> 上，因此 <code>CPU</code> 资源越多就运行越快。</p>
<p>除了应用程序，操作系统遇到的一个新的问题是多处理器调度。</p>
<h2 id="背景多处理器架构"><a href="#背景多处理器架构" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>背景：多处理器架构</h2>
<p>多处理器与单 <code>CPU</code> 之间的基本区别的核心在于对硬件缓存的使用，以及多处理器之间共享数据的方式。</p>
<p>在单 <code>CPU</code> 系统中，存在多级的硬件缓存，一般来说会让处理器更快地执行程序。缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。</p>
<p>举个例子，假设一个程序需要从内存中加载指令并读取一个值，系统只有一个 <code>CPU</code>，拥有较小的缓存（如 <code>64KB</code>）和较大的内存。</p>
<p>程序第一次读取数据时，数据在内存中，因此需要花费较长的时间（可能数十或数百纳秒）。处理器判断该数据很可能会被再次使用，因此将其放入 <code>CPU</code> 缓存中。如果之后程序再次需要使用同样的数据，<code>CPU</code> 会先查找缓存。因为在缓存中找到了数据，所以取数据快得多（比如几纳秒），程序也就运行更快。</p>
<p>缓存是基于局部性的概念，局部性有两种，时间局部性和空间局部性。时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为 <code>x</code> 的数据时，很有可能会紧接着访问 <code>x</code> 周围的数据，比如遍历数组或指令的顺序执行。由于这两种局部性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行得很好。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-027.png" alt=""></p>
<p>如果系统有多个处理器，并共享同一个内存，会怎么样呢？</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-028.png" alt=""></p>
<p>缓存一致性问题——例如，假设一个运行在 <code>CPU 1</code> 上的程序从内存地址 <code>A</code> 读取数据。由于不在 <code>CPU 1</code> 的缓存中，所以系统直接访问内存，得到值 <code>D</code>。程序然后修改了地址 <code>A</code> 处的值，只是将它的缓存更新为新值 <code>D'</code>。将数据写回内存比较慢，因此系统（通常）会稍后再做。假设这时操作系统中断了该程序的运行，并将其交给 <code>CPU 2</code>，重新读取地址 <code>A</code> 的数据，由于 <code>CPU 2</code> 的缓存中并没有该数据，所以会直接从内存中读取，得到了旧值 <code>D</code>，而不是正确的值 <code>D'</code>。</p>
<p>通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果 <code>CPU</code> 发现对它放在缓存中的数据的更新，会作废本地副本（从缓存中移除），或更新它（修改为新值）。</p>
<h2 id="别忘了同步"><a href="#别忘了同步" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>别忘了同步</h2>
<p>跨 <code>CPU</code> 访问（尤其是写入）共享数据或数据结构时，需要使用互斥原语（比如锁），才能保证正确性。。例如，假设多CPU并发访问一个共享队列。如果没有锁，即使有底层一致性协议，并发地从队列增加或删除元素，依然不会得到预期结果。需要用锁来保证数据结构状态更新的原子性。</p>
<p>例如，用于删除共享链表的一个元素。假设两个 <code>CPU</code> 上的不同线程同时进入这个函数。如果 <code>线程1</code> 执行第一行，会将 <code>head</code> 的当前值存入它的 <code>tmp</code> 变量。如果 <code>线程2</code> 接着也执行第一行，它也会将同样的 <code>head</code> 值存入它自己的私有 <code>tmp</code> 变量（<code>tmp</code> 在栈上分配，因此每个线程都有自己的私有存储）。因此，两个线程会尝试删除同一个链表头，而不是每个线程移除一个元素，这导致了各种问题（比如重复释放头元素，以及可能两次返回同一个数据）。</p>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__Node_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">__Node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">List_Pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Node_t</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>       <span class="c1">// remember old head ...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>  <span class="c1">// ... and its value
</span><span class="c1"></span>    <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>        <span class="c1">// advance head to next pointer
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>                <span class="c1">// free old head
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>             <span class="c1">// return value at head
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table></div>
</div>
</div><p>当然，让这类函数正确工作的方法是加锁。这里只需要一个互斥锁（，然后在函数开始时调用 <code>lock(&amp;m)</code>，在结束时调用 <code>unlock(&amp;m)</code>，确保代码的执行如预期。我们会看到，这里依然有问题，尤其是性能方面。具体来说，随着 <code>CPU</code> 数量的增加，访问同步共享的数据结构会变得很慢。</p>
<h2 id="最后一个问题缓存亲和度"><a href="#最后一个问题缓存亲和度" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>最后一个问题：缓存亲和度</h2>
<p>在设计多处理器调度时遇到的最后一个问题，是所谓的缓存亲和度：一个进程在某个 <code>CPU</code> 上运行时，会在该 <code>CPU</code> 的缓存中维护许多状态。下次该进程在相同 <code>CPU</code> 上运行时，由于缓存中的数据而执行得更快。相反，在不同的 <code>CPU</code> 上执行，会由于需要重新加载数据而很慢（硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，并尽可能将进程保持在同一个 <code>CPU</code> 上。</p>
<h2 id="单队列调度"><a href="#单队列调度" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>单队列调度</h2>
<p>设计一个多处理器系统的调度程序。最基本的方式是简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中，我们称之为单队列多处理器调度（<code>SQMS</code>）。这个方法最大的优点是简单。它不需要太多修改，就可以将原有的策略用于多个 <code>CPU</code>，选择最适合的工作来运行（例如，如果有两个 <code>CPU</code>，它可能选择两个最合适的工作）。</p>
<p>然而，<code>SQMS</code> 有几个明显的短板。第一个是缺乏可扩展性。为了保证在多 <code>CPU</code> 上正常运行，调度程序的开发者需要在代码中通过加锁来保证原子性，如上所述。在 <code>SQMS</code> 访问单个队列时（如寻找下一个运行的工作），锁确保得到正确的结果。</p>
<p>然而，锁可能带来巨大的性能损失，尤其是随着系统中的 <code>CPU</code> 数增加时。随着这种单个锁的争用增加，系统花费了越来越多的时间在锁的开销上，较少的时间用于系统应该完成的工作。</p>
<p><code>SQMS</code> 的第二个主要问题是缓存亲和性。比如，假设我们有 <code>5</code> 个工作（<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>）和 <code>4</code> 个处理器。调度队列如下：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-029.png" alt=""></p>
<p>一段时间后，假设每个工作依次执行一个时间片，然后选择另一个工作，下面是每个 <code>CPU</code> 可能的调度序列：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-030.png" alt=""></p>
<p>由于每个CPU都简单地从全局共享的队列中选取下一个工作执行，因此每个工作都不断在不同 <code>CPU</code> 之间转移，这与缓存亲和的目标背道而驰。</p>
<p>为了解决这个问题，大多数 <code>SQMS</code> 调度程序都引入了一些亲和度机制，尽可能让进程在同一个 <code>CPU</code> 上运行。保持一些工作的亲和度的同时，可能需要牺牲其他工作的亲和度来实现负载均衡。例如，针对同样的 <code>5</code> 个工作的调度如下：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-031.png" alt=""></p>
<p>这种调度中，<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 这 <code>4</code> 个工作都保持在同一个 <code>CPU</code> 上，只有工作E不断地来回迁移，从而尽可能多地获得缓存亲和度。为了公平起见，之后我们可以选择不同的工作来迁移。但实现这种策略可能很复杂。</p>
<p><code>SQMS</code> 调度方式有优势也有不足。优势是能够从单 <code>CPU</code> 调度程序很简单地发展而来，根据定义，它只有一个队列。然而，它的扩展性不好（由于同步开销有限），并且不能很好地保证缓存亲和度。</p>
<h2 id="多队列调度"><a href="#多队列调度" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>多队列调度</h2>
<p>正是由于单队列调度程序的这些问题，有些系统使用了多队列的方案，比如每个 <code>CPU</code> 一个队列。我们称之为多队列多处理器调度（<code>MQMS</code>）</p>
<p>在 <code>MQMS</code> 中，基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则，比如轮转或其他任何可能的算法。当一个工作进入系统后，系统会依照一些启发性规则（如随机或选择较空的队列）将其放入某个调度队列。这样一来，每个 <code>CPU</code> 调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题。</p>
<p>例如，假设系统中有两个 <code>CPU</code>（<code>CPU 0</code> 和 <code>CPU 1</code>）。这时一些工作进入系统：<code>A</code>、<code>B</code>、<code>C</code> 和 <code>D</code>。由于每个 <code>CPU</code> 都有自己的调度队列，操作系统需要决定每个工作放入哪个队列。可能像下面这样做：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-032.png" alt=""></p>
<p>根据不同队列的调度策略，每个CPU从两个工作中选择，决定谁将运行。例如，利用轮转，调度结果可能如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-033.png" alt=""></p>
<p><code>MQMS</code> 比 <code>SQMS</code> 有明显的优势，它天生更具有可扩展性。队列的数量会随着 <code>CPU</code> 的增加而增加，因此锁和缓存争用的开销不是大问题。此外，<code>MQMS</code> 天生具有良好的缓存亲和度。所有工作都保持在固定的 <code>CPU</code> 上，因而可以很好地利用缓存数据。</p>
<p>但是有一个新问题（这在多队列的方法中是根本的），即负载不均。假定和上面设定一样（<code>4</code> 个工作，<code>2</code> 个 <code>CPU</code>），但假设一个工作（如 <code>C</code>）这时执行完毕。现在调度队列如下：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-034.png" alt=""></p>
<p>如果对系统中每个队列都执行轮转调度策略，会获得如下调度结果：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-035.png" alt=""></p>
<p>从图中可以看出，<code>A</code> 获得了 <code>B</code> 和 <code>D</code> 两倍的 <code>CPU</code> 时间，这不是期望的结果。更糟的是，假设 <code>A</code> 和 <code>C</code> 都执行完毕，系统中只有 <code>B</code> 和 <code>D</code>：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-036.png" alt=""></p>
<p>处理负载不均问题的答案是让工作移动，这种技术我们称为迁移。通过工作的跨 <code>CPU</code> 迁移，可以真正实现负载均衡。</p>
<p>同样，有一个 <code>CPU</code> 空闲，另一个 <code>CPU</code> 有一些工作：</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-037.png" alt=""></p>
<p>在这种情况下，期望的迁移很容易理解：操作系统应该将 <code>B</code> 或 <code>D</code> 迁移到 <code>CPU 0</code>。这次工作迁移导致负载均衡。</p>
<p>更棘手的情况是，<code>A</code> 独自留在 <code>CPU 0</code> 上，<code>B</code> 和 <code>D</code> 在 <code>CPU 1</code> 上交替运行。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-038.png" alt=""></p>
<p>在这种情况下，单次迁移并不能解决问题。需要不断地迁移一个或多个工作。一种可能的解决方案是不断切换工作，如下面的时间线所示。可以看到，开始的时候 <code>A</code> 独享 <code>CPU 0</code>，<code>B</code> 和 <code>D</code> 在 <code>CPU 1</code>。一些时间片后，<code>B</code> 迁移到 <code>CPU 0</code> 与 <code>A</code> 竞争，<code>D</code> 则独享 <code>CPU 1</code> 一段时间。这样就实现了负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-039.png" alt=""></p>
<p>当然，还有其他不同的迁移模式。但系统如何决定发起这样的迁移？</p>
<p>一个基本的方法是采用一种技术，名为工作窃取。通过这种方法，工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。</p>
<p>当然，如果太频繁地检查其他队列，就会带来较高的开销，可扩展性不好，而这是多队列调度最初的全部目标！相反，如果检查间隔太长，又可能会带来严重的负载不均。</p>
<h2 id="linux-多处理器调度"><a href="#linux-多处理器调度" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><code>Linux</code> 多处理器调度</h2>
<p>在构建多处理器调度程序方面，<code>Linux</code> 社区一直没有达成共识。一直以来，存在 <code>3</code> 种不同的调度程序：<code>O(1)</code> 调度程序、完全公平调度程序（<code>CFS</code>）以及 <code>BF</code> 调度程序（<code>BFS</code>）。</p>
<p><code>O(1)</code>、<code>CFS</code> 采用多队列，而 <code>BFS</code> 采用单队列，这说明两种方法都可以成功。当然它们之间还有很多不同的细节。例如，<code>O(1)</code> 调度程序是基于优先级的（类似于之前介绍的 <code>MLFQ</code>），随时间推移改变进程的优先级，然后调度最高优先级进程，来实现各种调度目标。交互性得到了特别关注。与之不同，<code>CFS</code> 是确定的比例调度方法（类似之前介绍的步长调度）。<code>BFS</code> 作为三个算法中唯一采用单队列的算法，也基于比例调度，但采用了更复杂的方案，称为最早最合适虚拟截止时间优先算法（<code>EEVEF</code>）。</p>
            </div>

            
    
    
        <ul class="post-copyright">
            <li class="copyright-item author"><span class="copyright-item-text">作者</span>：<a href="https://arthur940621.github.io/" class="p-author h-card" target="_blank" rel="noopener">arthur</a></li>
            
                
                
                
                
                <li class="copyright-item link"><span class="copyright-item-text">链接</span>：<a href="/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">https://Arthur940621.github.io/technology/ostepcpu虚拟化/</a></li>
            
            
        </ul>
    



        </article>

        

        
    <div class="updated-badge-container">
        <span title="Updated @ 2021-12-02 20:33:30 CST" style="cursor:help">

<svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2021-12-02</text><text x="915" y="140" textLength="650" transform="scale(.1)">2021-12-02</text></g></svg>
        </span></div>



        


        <div class="post-share">

        

        <div class="share-items">

            
                <div class="share-item twitter">
                    
                    <a href="https://twitter.com/share?url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;text=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;hashtags=&amp;via=%25!s%28%3cnil%3e%29" title="分享到「Twitter」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon twitter-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a>
                </div>
            

            
                <div class="share-item facebook">
                    
                    <a href="https://www.facebook.com/sharer/sharer.php?u=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;hashtag=%23" title="分享到「Facebook」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon facebook-icon"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></a>
                </div>
            

            
                <div class="share-item linkedin">
                    
                    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;title=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;summary=%e2%80%a6%e2%80%a6&amp;source=%e9%98%bf%e9%a3%92%e7%9a%84%e4%bb%93%e5%ba%93" title="分享到「LinkedIn」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon linkedin-icon"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg></a>
                </div>
            

            
                <div class="share-item telegram">
                    
                    <a href="https://t.me/share/url?url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;text=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96" title="分享到「Telegram」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon telegram-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a>
                </div>
            

            
                <div class="share-item weibo">
                    
                    <a href="https://service.weibo.com/share/share.php?&amp;url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;title=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;pic=https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png&amp;searchPic=false" title="分享到「新浪微博」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon weibo-icon"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7 0 395.3 0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"/></svg></a>
                </div>
            

            
                <div class="share-item douban">
                    
                    <a href="https://www.douban.com/share/service?href=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;name=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;text=%e2%80%a6%e2%80%a6" title="分享到「豆瓣」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon douban-icon"><path d="M.643.92v2.412h22.714V.92H.643zm1.974 4.926v9.42h18.764v-9.42H2.617zm2.72 2.408H18.69v4.605H5.338V8.254zm1.657 7.412l-2.512.938c1.037 1.461 1.87 2.825 2.512 4.091H0v2.385h24v-2.385h-6.678c.818-1.176 1.589-2.543 2.303-4.091l-2.73-.938a29.952 29.952 0 01-2.479 5.03h-4.75c-.786-1.962-1.677-3.641-2.672-5.03Z"/></svg></a>
                </div>
            

            
                <div class="share-item qq">
                    
                    <a href="https://connect.qq.com/widget/shareqq/index.html?url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;title=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;summary=%e2%80%a6%e2%80%a6&amp;pics=https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png&amp;site=%e9%98%bf%e9%a3%92%e7%9a%84%e4%bb%93%e5%ba%93" title="分享到「QQ」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qq-icon"><path d="M433.754 420.445c-11.526 1.393-44.86-52.741-44.86-52.741 0 31.345-16.136 72.247-51.051 101.786 16.842 5.192 54.843 19.167 45.803 34.421-7.316 12.343-125.51 7.881-159.632 4.037-34.122 3.844-152.316 8.306-159.632-4.037-9.045-15.25 28.918-29.214 45.783-34.415-34.92-29.539-51.059-70.445-51.059-101.792 0 0-33.334 54.134-44.859 52.741-5.37-.65-12.424-29.644 9.347-99.704 10.261-33.024 21.995-60.478 40.144-105.779C60.683 98.063 108.982.006 224 0c113.737.006 163.156 96.133 160.264 214.963 18.118 45.223 29.912 72.85 40.144 105.778 21.768 70.06 14.716 99.053 9.346 99.704z"/></svg></a>
                </div>
            

            
                <div class="share-item qzone">
                    
                    <a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://Arthur940621.github.io/technology/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96/&amp;title=OSTEP%e2%80%94%e2%80%94CPU%e8%99%9a%e6%8b%9f%e5%8c%96&amp;summary=%e2%80%a6%e2%80%a6&amp;pics=https://raw.githubusercontent.com/Arthur940621/image/main/OSTEP/OSTEP-01-001.png&amp;site=%e9%98%bf%e9%a3%92%e7%9a%84%e4%bb%93%e5%ba%93" title="分享到「QQ 空间」" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon qzone-icon"><path d="M23.985 9.202c-.032-.099-.127-.223-.334-.258-.207-.036-7.351-1.406-7.351-1.406s-.105-.022-.198-.07c-.092-.047-.127-.167-.127-.167S12.447.956 12.349.77C12.25.583 12.104.532 12 .532c-.104 0-.251.051-.349.238-.098.186-3.626 6.531-3.626 6.531s-.035.12-.128.167c-.092.047-.197.07-.197.07S.556 8.908.348 8.943c-.208.036-.302.16-.333.258a.477.477 0 0 0 .125.449l5.362 5.49s.072.08.119.172c.016.104.005.21.005.21s-1.189 7.242-1.22 7.45.075.369.159.43c.083.062.233.106.421.013.189-.093 6.812-3.261 6.812-3.261s.098-.044.201-.061c.103-.017.201.061.201.061s6.623 3.168 6.812 3.261c.188.094.338.049.421-.013a.463.463 0 0 0 .159-.43c-.021-.14-.93-5.677-.93-5.677.876-.54 1.425-1.039 1.849-1.747-2.594.969-6.006 1.717-9.415 1.866-.915.041-2.41.097-3.473-.015-.678-.071-1.17-.144-1.243-.438-.053-.215.054-.46.545-.831a2640.5 2640.5 0 0 1 2.861-2.155c1.285-.968 3.559-2.47 3.559-2.731 0-.285-2.144-.781-4.037-.781-1.945 0-2.275.132-2.811.168-.488.034-.769.005-.804-.138-.06-.248.183-.389.588-.568.709-.314 1.86-.594 1.984-.626.194-.052 3.082-.805 5.618-.535 1.318.14 3.244.668 3.244 1.276 0 .342-1.721 1.494-3.225 2.597-1.149.843-2.217 1.561-2.217 1.688 0 .342 3.533 1.241 6.689 1.01l.003-.022c.048-.092.119-.172.119-.172l5.362-5.49a.477.477 0 0 0 .127-.449z"/></svg></a>
                </div>
            

            
                <div class="share-item qrcode">
                    <div class="qrcode-container" title="通过「二维码」"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon qrcode-icon"><path d="M0 224h192V32H0v192zM64 96h64v64H64V96zm192-64v192h192V32H256zm128 128h-64V96h64v64zM0 480h192V288H0v192zm64-128h64v64H64v-64zm352-64h32v128h-96v-32h-32v96h-64V288h96v32h64v-32zm0 160h32v32h-32v-32zm-64 0h32v32h-32v-32z"/></svg><div id="qrcode-img"></div>
                    </div>
                    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>

<script>
    var typeNumber = 0;
    var errorCorrectionLevel = 'L';
    var qr = qrcode(typeNumber, errorCorrectionLevel);
    qr.addData('https:\/\/Arthur940621.github.io\/technology\/ostepcpu%E8%99%9A%E6%8B%9F%E5%8C%96\/');
    qr.make();
    document.getElementById('qrcode-img').innerHTML = qr.createImgTag();
</script>

                </div>
            

        </div>

    </div>




        
    
    



        
    



        


        


        
    
        
        
    
    
    
    
        <ul class="post-nav">
            
                <li class="post-nav-prev">
                    <a href="/technology/leetcode%E5%88%B7%E9%A2%98%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" rel="prev">&lt; LeetCode刷题——最接近的三数之和</a>
                </li>
            
            
                <li class="post-nav-next">
                    <a href="/technology/leetcode%E5%88%B7%E9%A2%98%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/" rel="next">LeetCode刷题——合并两个有序数组 &gt;</a>
                </li>
            
        </ul>
    



        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            
    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="site-info">©&nbsp;2021–2021&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;arthur</div><div class="powered-by">Powered by <a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">Hugo</a> | Theme is <a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener">MemE</a></div><div class="site-copyright"></div>
                <div class="busuanzi-site-uv-and-pv">
                    <span id="busuanzi_container_site_uv">本站访客数&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon busuanzi-site-uv"><path d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"/></svg>&nbsp;<span id="busuanzi_value_site_uv"></span></span>&nbsp;|&nbsp;<span id="busuanzi_container_site_pv">本站访问量&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="icon busuanzi-site-pv"><path d="M288 144a110.94 110.94 0 0 0-31.24 5 55.4 55.4 0 0 1 7.24 27 56 56 0 0 1-56 56 55.4 55.4 0 0 1-27-7.24A111.71 111.71 0 1 0 288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400c-98.65 0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 400 288 400z"/></svg>&nbsp;<span id="busuanzi_value_site_pv"></span></span>
                </div>

            


            
        </div>
    </footer>


        </div>
        

        








    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    let imgNodes = document.querySelectorAll('div.post-body img');
    imgNodes = Array.from(imgNodes).filter(node => node.parentNode.tagName !== "A");

    mediumZoom(imgNodes, {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>




    <script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js" type="module" defer></script>




    
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    




    </body>
</html>
